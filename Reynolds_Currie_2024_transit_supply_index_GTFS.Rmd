---
title: "Transit Supply Index scores on the days of the 2016 and 2021 censuses: using Statistical Area Level 1 (SA1) 2016 boundaries"
runningheader: "Reynolds and Currie" # only for pdf output
author: "James Reynolds and Graham Currie"
date: "`r Sys.Date()`"
output:
  tufte::tufte_book:
    citation_package: natbib
    latex_engine: xelatex
bibliography: [packages.bib, References.bib]
link-citations: yes
header-includes:
  - \usepackage{titling}
  - \pretitle{\begin{center}
    \includegraphics[width=2in,height=2in]{ptrg-logo-s.png}\LARGE\\}
  - \posttitle{\end{center}}
---

```{r setup, include=FALSE}
library(tufte)

library(tidyverse)
library(sp)
library(absmapsdata)
library(ptinpoly)
library(magrittr)
library(ggplot2)
library(sf)
library(ASGS.foyer)
library(raster)
library(ggmap)
library(units)
library(janitor)
library(mapview)
library(ggstatsplot)
library(gtsummary)
library(moments)
library(scales)
library(gtfstools)
library(lubridate)
library(kableExtra)
library(knitr)
library(readxl)
library(dplyr)
library(rvest)

# invalidate cache when the tufte version changes
#knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
```

# Introduction

Previous research by @currie2007identifying developed a transit Supply Index (SI), based on calculating the number of transit arrivals at stops within an area of interest, adjusted to account for the typical walk-access catchment for each stop. The Public Transport Research Group (PTRG) has been developing R code to calculate this Supply Index directly from GTFS data. 

This document describes results from using the code to output SI scores for the day of the 2016 census and the day of the 2021 census for each of the Australian Bureau of Statistics (ABS) 2016 Statistical Area Level 1 (SA1) zones in Victoria^[These scores have been requested by Maryam Jafari as an input to her PhD project.]. It also presents verification checks to determine the accuracy of the output scores, and shows some statistical analysis of the scores as a way of exploring the output. 

This rest of this document is structured as follows: the next section discusses the research context of the Supply Index. In the third section the methodology for the code development is outlined, including discussion of the overall context of the Victoria, Australia, case for which the scores are being calculated. It also discusses the individual (sub-)cases within Victoria^[An SA1 in the Alpine area, SA1s within the Clayton SA2 area and SA1s within the Melbourne City SA3 area] used to verify and explore the scores outputted by the code. In the fourth section results are presented, including the verification results, exploration of the scores across Clayton and Melbourne City,  and a review of the SI scores for SA1s across all of Victoria. The document then closes with a brief discussion and conclusion.

# Research context

## The Suppy Index

```{marginfigure}
\begin{equation}
\label{eq:supply_index}
SI_{area, time} = \sum{\frac{Area_{Bn}}{Area_{area}}*SL_{n, time}}
\end{equation}
```

Equation \ref{eq:supply_index}^[In Equation \ref{eq:supply_index} $SI_{area, time}$ is the Supply Index for the area of interest and a given period of time. $Area_{Bn}$ is the buffer area for each stop (n) within the area of interest. In @currie2007identifying this was based on a radius of 400 metres for bus and tram stops, and 800 metres for railway stations. $Area_area$ is the area of the area of interest, and $SL_{n,time}$ is the number of transit arrivals for each stop for a given time period.
] shows the Supply Index^[Minor adjustments have been made to generalise the equation, as @currie2007identifying focused on the context of Melbourne's Census Collection Districts (CCD) and calculations based on a week of transit service.]. It describes the number of transit arrivals at stops within an area of interest and time frame, multiplied by a factor accounting for the proportion of the area of interest that is within typical walking distance of each stop. Hence, more services, more stops and higher frequencies would all result in an increase in Supply Index score. 

The Supply Index does not incorporate further aspects, such as service span, off-peak share of service or service speed, which are a feature of the Transit Capaicity and Quality of Service Manual (TCQSM) [@TCQSM:2013] and other transit supply metrics. However, including such factors may increase the complexity of calculating and describing the index. 

Simplicity is also helped by the way that the SI is additive. Hence, $SI_{area, time}$ scores can be aggregated to calculate an overall score across multiple time periods or for a region encompassing multiple areas of interest.


@currie2007identifying calculated the $SI_{area, time}$ for various Census Collection Districts (CCDs)^[CCDs predate the introduction of Statistical Areas 1, 2, 3, and 4 (SA1, SA2, SA3, SA4), and other geographical divisions currently used by the Australian Bureau of Statistics (ABS), which may be more familiar to readers.] in Melbourne using a timetable database provided by the Victorian Public Transport Authority (PTA). This predated the widespread availability of GTFS data. A question, therefore, is how to calculate the SI using GTFS data so that $SI_{area, time}$ scores can be calculated and compared for any area of interest where transit service information is available in that format.


# Methodology

This document has been prepared using Rmarkdown, which allows the intermingling of written text, code segments and code outputs. Code segments developed in this research are shown in the following, together with the relevant descriptive text^[The Rmarkdown file is available at https://github.com/James-Reynolds/Transit_Supply_Index_GTFS/tree/SA12016_analysis and this can be read in a plain-text editor to view the code snippets themselves. If you are reading this in a PDF document you are seeing just the descriptive text, and outputs from the code where it has been run to produce maps, charts etc.]. This specific document is part of a branch of the developed code, specifically created for reporting the calculation of the SI scores for the SA12016 zones.

Various analysis tools are available that make use of GTFS data, including the tidytransit package [@R-tidytransit] for the R statistical programming language [@R-base]. @tidytransit_departure_timetable provides code to calculate a departure timetable from a GTFS feed, and this was adapted to calculate arrivals at a stop and the SL~Bn~ term in the @currie2007identifying SI equation.

```{r arrival_timetable_as_a_function, echo=FALSE, warnings=FALSE, messages=FALSE, cache=TRUE}

#This was code was developed for another project (https://github.com/James-Reynolds/DEAKIN-housing-and-transit-accessibility),  based on the tidytransit vignette on producing a departure timetable (@tidytransit_departure_timetable.  There is back history availlble at at that github repository  for further details, but basically I wrote a departure_timetable_function and fixed up a bit where it wasn't accounting for through-running services.  This was then directly adjusted to create an arrival_timetable function (below) --- However, I did not adjust all the variable names in the function to reflect that it is about arrivals, not departures. 
#---also, something broke in the first few lines where it adds the trip_origins to the gtfs$trips data.  Not quite sure what broke, but the first 15 lines of the below function fixes it. 

library(tidytransit)
#gtfs <- read_gtfs("data/1google_transit.zip")
#stop_to_show <- "Wallan Railway Station (Wallan)"
#date_to_show <- "2023-04-27"

arrival_timetable_function <- function(gtfs, stop_to_show, date_to_show){
  # get the id of the first stop in the trip's stop sequence

  first_stop_id <- gtfs$stop_times %>% 
    group_by(trip_id) 

  first_stop_id <- first_stop_id %>%
      filter(stop_sequence == which.min(stop_sequence)) %>%
      summarise(trip_id, stop_id)

  # join with the stops table to get the stop_name
  first_stop_names <- left_join(first_stop_id, gtfs$stops, by="stop_id")

  # rename the first stop_name as trip_origin
  trip_origins <- first_stop_names %>% select(trip_id, trip_origin = stop_name)

  # join the trip origins back onto the trips
  gtfs$trips <- left_join(gtfs$trips, trip_origins, by = "trip_id")
  
  #### get the id of the last stop in the trip's stop sequence
  last_stop_id <- gtfs$stop_times %>% 
    group_by(trip_id) %>% 
    summarise(stop_id = stop_id[which.max(stop_sequence)])

  # join with the stops table to get the stop_name
  last_stop_names <- left_join(last_stop_id, gtfs$stops, by="stop_id")

  # rename the last stop_name as trip_destination
  trip_destinations <- last_stop_names %>% dplyr::select(trip_id, trip_destination = stop_name)

  # join the trip destinations back onto the trips
  gtfs$trips <- left_join(gtfs$trips, trip_destinations, by = "trip_id")

  
  #gtfs$trips %>%
  #  dplyr::select(route_id, trip_origin) %>%
  #  head()

  if(!exists("trip_headsign", where = gtfs$trips)) {
    # get the last id of the trip's stop sequence
    trip_headsigns <- gtfs$stop_times %>% 
      group_by(trip_id) %>% 
      summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
      left_join(gtfs$stops, by="stop_id") %>% dplyr::select(trip_id, trip_headsign.computed = stop_name)

  #create a new field with 
  trip_destination <- gtfs$stop_times %>% 
      group_by(trip_id) %>% 
      summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
      left_join(gtfs$stops, by="stop_id") %>% dplyr::select(trip_id, trip_headsign.computed = stop_name)

    
    
    # assign the headsign to the gtfs object 
    gtfs$trips <- left_join(gtfs$trips, trip_headsigns, by = "trip_id")
  }

  stop_ids <- gtfs$stops %>% 
    filter(stop_name == stop_to_show) %>% 
    dplyr::select(stop_id)

  departures <- stop_ids %>% 
    inner_join(gtfs$stop_times %>% 
                 dplyr::select(trip_id, arrival_time, 
                        departure_time, stop_id), 
               by = "stop_id")
  
  departures <- departures %>% 
    left_join(gtfs$trips %>% 
                dplyr::select(trip_id, route_id, 
                       service_id, trip_headsign, 
                       trip_origin, 
                       trip_destination), 
              by = "trip_id") 
  
  departures <- departures %>% 
    left_join(gtfs$routes %>% 
                dplyr::select(route_id, 
                       route_short_name), 
              by = "route_id")

  #remove trips where first stop is equal to the stop_to_show, as these stops originate at this stop and so do not depart
  departures <- departures %>% 
      filter(trip_origin != stop_to_show)
  
  
  #departures %>% 
  #  dplyr::select(arrival_time,
  #         departure_time,
  #         trip_headsign,trip_origin,
  #         route_id) %>%
  #  head() %>%
  #  knitr::kable()

  #head(gtfs$.$dates_services)


  services_on_180823 <- gtfs$.$dates_services %>% 
    filter(date == date_to_show) %>% dplyr::select(service_id)

  departures_180823 <- departures %>% 
    inner_join(services_on_180823, by = "service_id")

#  departures_180823 %>%
 #   arrange(departure_time, stop_id, route_short_name) %>% 
  #  dplyr::select(departure_time, stop_id, route_short_name, trip_headsign) %>% 
   # filter(departure_time >= hms::hms(hours = 7)) %>% 
   # filter(departure_time < hms::hms(hours = 7, minutes = 10)) %>% 
  #  knitr::kable()

  route_colors <- gtfs$routes %>% dplyr::select(route_id, route_short_name, route_color)
  route_colors$route_color[which(route_colors$route_color == "")] <- "454545"
  route_colors <- setNames(paste0("#", route_colors$route_color), route_colors$route_short_name)

  #No need for list of outputs anymore, as the graphs are no longer needed
  #output <- list(
   #   ggplot(departures_180823) + theme_bw() +
    #  geom_point(aes(y=trip_origin, x=arrival_time, color = route_short_name), size = 0.2) +
     # scale_x_time(breaks = seq(0, max(as.numeric(departures$departure_time)), 3600), 
      #             labels = scales::time_format("%H:%M")) +
      #theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
      #theme(legend.position = "bottom") +
      #scale_color_manual(values = route_colors) 
  #    labs(title = paste("Departures from", stop_to_show, "on", date_to_show))
  #add a return value to provide the number of services shown in the graph as an output
       #   , nrow(departures_180823)
    #  )
  #return list with graph and the number of services. 
  return(departures_180823)
  
}
#arrivals_southern_cross_230427 <- arrival_timetable_function(gtfs=mel1, stop_to_show="Southern Cross Railway Station (Melbourne City)", date_to_show="2023-04-27")
#head(arrivals_southern_cross_230427)
```

The gtfstools R package [@R-gtfstools] was used to split input GTFS feeds by mode to facilitate the buffer zone calculation. Buffer zones of 400 metres for bus and Light Rail Transit (LRT) services and 800 metres for heavy rail were adopted, as per @currie2007identifying^[There is an extended mode definition that includes modes beyond the 10 in the GTFS standard [@filter_GTFS_by_mode], but these are not dealt with by the gtfstools package. Further research may seek to extend this such that other modes can be included, but for the purposes of this study the coded buffer zone was set at 400 metres for cable trams, aerial lifts such a gondolas and trolleybuses, and at 800 metres for ferries, funiculars and monorails.].

```{r read_buffer_zone, echo=FALSE}

buffer_zone_definitions <- as_tibble(read.csv ("buffer_zones.csv"))

class(buffer_zone_definitions$code) <- "character"
buffer_zone_definitions$mode <- noquote(buffer_zone_definitions$mode)
buffer_zone_definitions$description_examples <- noquote(buffer_zone_definitions$description_examples)
class(buffer_zone_definitions$mode) <- "character"
class(buffer_zone_definitions$description_examples) <- "character"
#set buffer zone units to metres
buffer_zone_definitions$buffer <- as_units(buffer_zone_definitions$buffer, "m")

```

```{r split_gtfs_function, echo=FALSE}

split_gtfs_into_modes_and_put_in_list <- function(gtfs){ 
  gtfs_LRT <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 0))
  gtfs_subway <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 1))
  gtfs_rail <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 2))
  gtfs_bus <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 3))
  gtfs_ferry <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 4))
  gtfs_cable_tram <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 5))
  gtfs_aerial_lift <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 6))
  gtfs_funicular <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 7))
  gtfs_trolleybus <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 11))
  gtfs_monorail <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 12))
 

  gtfs_into_modes_and_put_in_list <- list(
    LRT = gtfs_LRT, 
    subway = gtfs_subway,
    rail = gtfs_rail,
    bus = gtfs_bus,
    ferry = gtfs_ferry, 
    cable_tram = gtfs_cable_tram, 
    aerial_lift = gtfs_aerial_lift, 
    funicular = gtfs_funicular, 
    trolleybus = gtfs_trolleybus,
    monorail = gtfs_monorail 
  )

  return(gtfs_into_modes_and_put_in_list)
}

```

Where transit stops are located close to boundaries their catchment areas may fall into multiple areas of interest. The sp package [@R-sf] provides tools for manipulating geographic data and shape files in R. This was used to calculate the proportion of each stop's catchment area that falls into each geographical area of interest^[GTFS files define stop locations based on latitude and longitude [@GTFS], whereas the Area~Bn~ calculation needs to be provided in the same units as the Area~area~ variable, necessitating the use of a geographic transform as part of the code.].


The proportional area term in the SI equation was calculated on a mode-by-mode and stop-by-stop basis, by first determining the amount of the catchment area (Area~Bn~) that falls into each geographical area of interest for the stop in question. This is then combined with the area for each geographical area of interest (Area~area~) and the number of stop arrivals (SL~Bn~) to calculate the contribution to the SI scores made by just that single stop for every area of interest. These are then added to a cumulative total field for each area of interest, and the calculations are repeated until all stops and modes in the GTFS file have been included.

```{r SICCD_calc_as_functions, echo=FALSE, warning=FALSE, message=FALSE}

###Temporary variables to help with writing the function
#areas_of_interest <- sa1_map_data %>%
#  filter(gcc_name_2021 == "Greater Melbourne") 
#mel3 <- read_gtfs("data/3google_transit.zip")
#mel3_list_by_mode <- split_gtfs_into_modes_and_put_in_list(mel3)
#gtfs_list_by_mode <- mel3_list_by_mode
#start_date = "2023-04-27"
#period_in_days = 2
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "sa1_code_2021"

#### The function ________
SI_calc_function <- function(areas_of_interest = areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = gtfs_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform){

  ##Initialise variables used in function
  #the top level list. First element is a tibble of areas_of_interest_id_field. The remainder of the list has one element for each day of analysis, with each element containing a tibble with the SI scores for each mode.   
  SI_list_by_date_and_mode <- list((tibble(areas_of_interest %>% select(as.character(areas_of_interest_id_field))) %>% select(!"geometry")))
  names(SI_list_by_date_and_mode) <- as.character(areas_of_interest_id_field)

  # convert to sf format and project
  areas_of_interest_sf <- areas_of_interest %>%
  # convert to simple features
  sf::st_as_sf() %>%
    st_transform(crs = EPSG_for_transform) 
  # add Area_area value to areas_of_interest_sf 
  areas_of_interest_sf <- areas_of_interest_sf %>% 
    dplyr::mutate(Area_area = st_area(areas_of_interest_sf))
  # Add SI column to areas_of_interest_sf
  areas_of_interest_sf <- areas_of_interest_sf %>% 
    dplyr::mutate(SI = 0)
    
#2-level list to put the SI results in, with each element representing one of the days that is being analysed. 
    # This becomes a list (of lists), with one element for each mode for the day_of_analysis in question (j)
    SI_for_day_of_analysis_list_by_mode <- list()
  
  #for loop that drives the first level of the list, recording the day of analysis
  for (j in seq(1, period_in_days, 1)) {
    
    ##Initialise variables used in first level of the list
    day_of_analysis = as.character(ymd(start_date) - days(1) + days(j))
    
    #dataframe to store the SIs for each area of interest by mode for day j
       SI_for_day_of_analysis_by_mode_k <- (tibble(areas_of_interest %>% select(as.character(areas_of_interest_id_field))) %>% select(!"geometry"))
    
    ##for loop that drives the second level of the list, recording SI by mode
      for (k in seq(1, length(names(gtfs_list_by_mode)), 1)){   
        #look up the buffer distance for mode k
        buffer_distance <- buffer_zone_definitions %>% filter(short_name == as.character(names(gtfs_list_by_mode[k]))) %>% select(buffer) %>% as.numeric()
     
        #add zero-ed column to store SIs for mode k
        SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k %>% tibble::add_column(a = 0)
        #change name of added column to match mode k
names(SI_for_day_of_analysis_by_mode_k) <- c( names(SI_for_day_of_analysis_by_mode_k[,1:ncol(SI_for_day_of_analysis_by_mode_k)-1]), eval(names(gtfs_list_by_mode[k])))                         
        
        #check if the gtfs mode in question has any stops - many of the modes (e.g. Monorail) will typically have zero services or stops.  If the mode in question (k) does not have any stops, then there is no further calculation required, and the existing column of zeros can be left as is. 
        if(nrow(gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]) > 0) { 
         SI_return_value_for_that_mode <- rep(0,nrow(areas_of_interest))
         #which is calculated in the following for loop, which passes over all of the stops in the gtfs file for the mode in question
          for (i in seq(1, nrow(gtfs_list_by_mode[[ as.character(names(gtfs_list_by_mode[k]))]][["stops"]]), 1)) {
      
            #create dataframe with stop i lat and lon value
            dat_sim <- data.frame(lat = gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]$stop_lat[i],
            long = gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]$stop_lon[i])
            # Convert that dataframe (with stop i latitude and longitude) into a sf object, with the crs set to EPSG:4326 (which is the CRS for lat/long values), 
           # and then transform to be expressed as per the EPSG that is being used for the analysis (ie. shift to metres)
            dat_sf <- st_as_sf(dat_sim, coords = c("long", "lat"), crs = 4326) %>% 
            st_transform(crs = EPSG_for_transform)
  
            # make a circle with the buffer distance as the radius around stop i    
            dat_circles <- st_buffer(dat_sf, dist = buffer_distance)
            # Intersect the circle with the polygons
            int_circles <- st_intersection(areas_of_interest_sf, dat_circles)

            ##TEST CODE Map to check that it is working the way it is expect to.
            #map <- int_circles %>%
              #ggplot() +
              #geom_sf(aes(geometry = geometry,  # use the geometry variable
                  #fill = eval(parse(text=areas_of_interest_id_field))),     # fill by SA1_code
                #lwd = 0,                  # remove borders
                #show.legend = TRUE) +    # keep legend
              #theme_void() +                    # clears other plot elements
              #coord_sf()
              
            #map

            #calculate Area Bn 
            int_circles$area_bn <- st_area(int_circles)
            
            #drop_geometry
            int_circles <- as.tibble(int_circles[, !(colnames(int_circles) %in% "geometry")])
  
            ##Retrieve number of arrivals for that mode and day by...
            #first moving the gtfs for that mode out of gtfs_list_by_mode
            gtfs_k <- as_tidygtfs(eval(parse(text = paste("gtfs_list_by_mode$",names(gtfs_list_by_mode)[k],sep = ""))))
            # then add the number of arrivals at stop i to all rows of the int_circles dataframe. 
            int_circles$SL_Bn <- rep(
              nrow(arrival_timetable_function(gtfs = gtfs_k, stop_to_show = gtfs_list_by_mode[[
                as.character(names(gtfs_list_by_mode[k]))]]$stops$stop_name[i], date_to_show = day_of_analysis)), 
              nrow(int_circles))
    
            #Calculate SI for stop i and drop units
            int_circles$add_to_SI <- as.numeric(int_circles$area_bn / int_circles$Area_area * int_circles$SL_Bn)
  
            
            #Create ordinary tibble with Area of Interest identification code and SIs from stop i to add to the running totals
            export_to_SI_for_day_of_analysis_by_mode_k <- int_circles %>% select(c(as.character(areas_of_interest_id_field), add_to_SI)) 
            
            #drop add_SI column from dataframe reporting SI_by_mode scores up to the date loop (SI_for_day_of_analysis_by_mode_k)
            SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[, !(colnames(SI_for_day_of_analysis_by_mode_k) %in% "add_to_SI")]
  
            #merge based on eval(parse(text=areas_of_interest_id_field))
            SI_for_day_of_analysis_by_mode_k <- left_join(SI_for_day_of_analysis_by_mode_k, export_to_SI_for_day_of_analysis_by_mode_k)
  
            #convert add_to_SI to non-unit numbers
            SI_for_day_of_analysis_by_mode_k$add_to_SI <- as.vector(SI_for_day_of_analysis_by_mode_k$add_to_SI)
  
            #replace NA with 0 
            SI_for_day_of_analysis_by_mode_k[is.na(SI_for_day_of_analysis_by_mode_k)] = 0
  
            #add the SIs for stop i to the running total of SI for the mode in question
            SI_for_day_of_analysis_by_mode_k[,eval(names(gtfs_list_by_mode[k]))] <- SI_for_day_of_analysis_by_mode_k[,eval(names(gtfs_list_by_mode[k]))] + SI_for_day_of_analysis_by_mode_k$add_to_SI
          
            print(c("stop", i, "mode", k, "day", j))
            #close (i) loop for calculating SIs for stop i and adding to the running total of SI
            }
        
        #close the if(no stops in gtfs for that mode) test 
        }
       
       #close for (k) loop for calculating SI for a single mode on a single day
      }  
       
      #drop area of interest id code from dataframe of SI by mode for the day of analysis
      SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[,2:ncol(SI_for_day_of_analysis_by_mode_k)]
      
      #drop add_to_SI column from dataframe of SI by mode for the day of analysis
      SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[,!names(SI_for_day_of_analysis_by_mode_k) %in% "add_to_SI"]
       
            #add new element to the list_by_date for the date_of_analysis
      SI_list_by_date_and_mode <- append(SI_list_by_date_and_mode, list(SI_for_day_of_analysis_by_mode_k), after = length(SI_list_by_date_and_mode))
    
      #update name of new element to match date
      names(SI_list_by_date_and_mode) <- c(names(SI_list_by_date_and_mode)[1:length(names(SI_list_by_date_and_mode))-1], as.character(day_of_analysis))

    #close for (j) loop for creating the list of days
    }        

 return(SI_list_by_date_and_mode)    

#close function     
}
  


#function to combine all days together. Outputs a dataframe with a row for each area_of_interest and a column for each mode
convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function <- function(SI_list_by_date_and_mode = SI_list_by_date_and_mode) {
  SI_df_by_mode <- SI_list_by_date_and_mode[2:length(names(SI_list_by_date_and_mode))] %>%
  map_dfr(~setNames(.x, paste0("A", 1:ncol(.x))), .id = "Group") %>%
  group_by(Group) %>%
  mutate(ID = 1:n()) %>%
  group_by(ID) %>%
  summarize(across(-Group, .fns = sum, na.rm = TRUE)) %>%
  select(-ID)

  #update column names to match modes
  names(SI_df_by_mode) <- colnames(SI_list_by_date_and_mode[[2]])
  
  #add back area_of_interest_id_ column
  SI_df_by_mode <- cbind(SI_list_by_date_and_mode[1], SI_df_by_mode)
  
  return(SI_df_by_mode)
}



```

## Case research approach

This document reports results for a single case, the state of Victoria. The state capital is in Melbourne, which has a similar metropolitan area to of Paris or London^[Greater Melbourne is the term used to describe the larger metropolitan area, encompassing 30 LGAs. The City of Melbourne LGA covers only a small portion of the inner city.
]. However, with only around 5 million people Melbourne has about one-third of the population density. It has an inner Central Business District (CBD) with apartments, commercial skyscrapers and extensive sporting facilities nearby; surrounded by low-density, predominately single-family-housing-dominated, inner, middle and outer suburbs.


There are train and tram networks radiating from the CBD, but for most of the suburban areas the reality is that transit is provided by circuitious bus routes that are mostly used by those who cannot otherwise drive. An extensive freeway (and tollway) network provides connections across the Greater Melbourne area, further around Port Phillip Bay to Geelong (south-west) and the Mornington Penninsula (south-east) as well as to regional centres elsewhere in Victoria. There is a state-wide regional train and bus network (VLine), which also provides connections into South Australia, New South Wales and the Australian Capital Territory (Canberra) and local bus services in many regional towns and cities. However, accessibility to most of the city and state tends to be car-dominated. The Overland train service to Adelaide and the XPT to Sydney are provided seperately to VLine services. Victoria's GTFS feed is published by Public Transport Victoria (PTV)^[There are over 400 historical releases of the available on the transitfeeds.com website, with the first dating from March 2015 [@transitfeeds_victoria:2023aa].].

For the results reported here output was obtained for SA1-level areas using GTFS files from August 2016 and 2021, running for just the day of the census in each year. The Australian Census is undertaken in early August every 5 years. GTFS feeds were therefore selected for the first week of August of each year, with code output produced for only the day of the census itself^[It takes about a day of processing time to run the code for all of the stops in Victoria for a single 'day' of service. Hence, only the census days (rather than weeks) were analysed to speed development.]. Minor corrections were made to the GTFS files to remove duplicate stop_ids^[These involved minor discrepancies in either the stop name, latitude or longitude.].



The Australian Bureau of Statistics (ABS) provides a range of shape files and other resources. This study made use of the absmapsdata R package [@R-absmapsdata] to access the SA1 boundaries for Victoria used during the 2016 census (SA1_2016)^[Note, there is also a set of SA1 boundaries that are relevant to the 2021 census (SA1_2021).]. The EPSG:28355 transform [@EPSG_28355] was used to shift longitude and latitude into metres, as per the Geocentric Datum of Australia 1994 (GDA95 / MGA zone 55) coordinates.

```{r load_abs_data, messages = FALSE, warnings = FALSE, echo=FALSE, fig.fullwidth=TRUE, fig.cap="Melbourne SA1 map"}
#Load SA1 data
sa1_map_data <- sa12016

##Map Greater Melbourne SA1 areas
#map <- sa1_map_data %>%
#  filter(gcc_name_2021 == "Greater Melbourne") %>%   # let's just look Melbourne
#  ggplot() +
#  geom_sf(aes(geometry = geometry,  # use the geometry variable
#              fill = areasqkm_2021),     # fill by area size
#          lwd = 0,                  # remove borders
#          show.legend = TRUE) +    # keep legend
# # geom_point(aes(cent_long,
#  #               cent_lat),        # use the centroid long (x) and lats (y)
#   #          colour = "white") +    # make the points white
#  theme_void() +                    # clears other plot elements
#  coord_sf()

#map

p <- sa1_map_data
p <- p %>% 
  dplyr::mutate(area = st_area(p))
units(p$area) <- as_units("m^2")




```

```{r Melbourne_2021, echo=FALSE, warning=FALSE, message=FALSE}
###Commented out as 2021 has been precalculated
#victoria_2021 <- read_gtfs("data/Melbourne/2021/gtfs.zip")

##identify duplicate stops
#victoria_2021_duplicated_stops <- tabyl(victoria_2021$stops$stop_id) %>% filter (n>1)
#names(victoria_2021_duplicated_stops) <- c("stop_id", "n", "percent")
#victoria_2021_duplicated_stops <- left_join(victoria_2021_duplicated_stops, victoria_2021$stops)

##discard duplicates
#victoria_2021$stops <- victoria_2021$stops[!duplicated(victoria_2021$stops$stop_id),]

##split modes
#victoria_2021_list_by_mode <- split_gtfs_into_modes_and_put_in_list(victoria_2021)


##set inputs to SI_calc function
#victoria_areas_of_interest <- sa12016 %>% filter(state_name_2016 == "Victoria")
#start_date = "2021-08-10"
#period_in_days = 1
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "sa1_code_2016"

##run SI_calc function
#victoria_2021_SI_list_by_date_and_mode <- SI_calc_function(areas_of_interest =  victoria_areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = victoria_2021_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform)

##run aggregation function to create df by mode for all 7 days
#victoria_2021_SI_df_by_mode <-  convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function(victoria_2021_SI_list_by_date_and_mode)

##write to csv
#write_csv2(victoria_2021_SI_df_by_mode, "~/Documents/0001_project/Transit_Supply_Index_GTFS/data/Melbourne/2021/Victoria_2021_SI_df_by_mode_SA12016_210810.csv")


#load pre-calculated df by mode (for just one day)
victoria_2021_SI_df_by_mode <- read_delim("results/Victoria_2021_SI_df_by_mode_SA12016_210810.csv", 
    delim = ";", locale = locale(decimal_mark = ","), escape_double = FALSE, col_types = cols(sa1_code_2016 = col_character(), 
        LRT = col_number(), subway = col_number(), 
        rail = col_number(), bus = col_number(), 
        ferry = col_number(), cable_tram = col_number(), 
        aerial_lift = col_number(), funicular = col_number(), 
        trolleybus = col_number(), monorail = col_number()), 
    trim_ws = TRUE)




#Join SI to map data
victoria_2021_SI_df_by_mode_sf <- left_join(victoria_2021_SI_df_by_mode, sa12016)

```

```{r Melbourne_2016, echo=FALSE, warning=FALSE, message=FALSE}
#victoria_2016 <- read_gtfs("data/Melbourne/2016/gtfs.zip")

##resolve route colour problem in gtfs file
#victoria_2016$routes$route_color <- 0

##identify duplicate stops
#victoria_2016_duplicated_stops <- tabyl(victoria_2016$stops$stop_id) %>% filter (n>1)
#names(victoria_2016_duplicated_stops) <- c("stop_id", "n", "percent")
#victoria_2016_duplicated_stops <- left_join(victoria_2016_duplicated_stops, victoria_2016$stops)

##discard duplicates
#victoria_2016$stops <- victoria_2016$stops[!duplicated(victoria_2016$stops$stop_id),]

##split modes
#victoria_2016_list_by_mode <- split_gtfs_into_modes_and_put_in_list(victoria_2016)


###set inputs to SI_calc function
#victoria_areas_of_interest <- sa1_map_data %>% filter(state_name_2016 == "Victoria")
#start_date = "2016-08-09"
#period_in_days = 1
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "sa1_code_2016"

##run SI_calc function
#victoria_2016_SI_list_by_date_and_mode <- SI_calc_function(areas_of_interest =  victoria_areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = victoria_2016_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform)

##run aggregation function to create df by mode 
#victoria_2016_SI_df_by_mode <-  convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function(victoria_2016_SI_list_by_date_and_mode)

##write to csv
#write_csv2(victoria_2016_SI_df_by_mode, "~/Documents/0001_project/Transit_Supply_Index_GTFS/results/Victoria_2016_SI_df_by_mode_SA12016_160809.csv")


#load pre-calculated df by mode (for just one day)
victoria_2016_SI_df_by_mode<- read_delim("results/Victoria_2016_SI_df_by_mode_SA12016_160809.csv", 
    delim = ";", locale = locale(decimal_mark = ","), escape_double = FALSE, col_types = cols(sa1_code_2016 = col_character(), 
        LRT = col_number(), subway = col_number(), 
        rail = col_number(), bus = col_number(), 
        ferry = col_number(), cable_tram = col_number(), 
        aerial_lift = col_number(), funicular = col_number(), 
        trolleybus = col_number(), monorail = col_number()), 
    trim_ws = TRUE)

#Join map data
victoria_2016_SI_df_by_mode_sf <- left_join(victoria_2016_SI_df_by_mode, sa12016)

```


Results were processed using the ggmaps [@R-ggmap], ggplot [@R-ggplot2], ggstatsplot [@R-ggstatsplot] and kable [@R-kableExtra; @R-knitr] packages, with data processing leveraging the tidyverse approach [@R-tidyverse].



### Sub-cases

The developed code has been separately tested using SA1- and LGA-level areas of interest, including hand verification of some example SA1 areas^[This testing is reported in the main branch of the project on GitHub. This document is instead specific to the calculation of the SI scores for the 2016 SA1 boundaries.]. Here the results are examined in detail for:  
 
- SA1 zone 20403106915, which covers Running Creek and Morgans Bridge, two localities in the Victorian Alps^[The aforementioned hand verification of example SA1 areas reported in the main branch of the project on GitHub also examined SA1 zone 20403106915. This is repeated here for consistency.]. Within this SA1 area there are only two V/Line bus stops: 

  - Stop ID: 45125, Running Creek Rd/Kiewa Valley Hwy (Running Creek) and
  - Stop ID: 45124, Kiewa Valley Hwy (Mongans Bridge).].  

This SA1 was selected for the purposes of verifying the code output as it is relatively easy to calculate the relevant SI values as a cross-check, because there is only one bus service and two stops to include. The location of the SA1 20403106915 is shown in Figure 1.  

![SA1 20403106915, with approximate location of Stop:ID 45125 highlighted, sources ABS and Google Maps](images/Running_creek_bus_stop.png)

- Output results for SA1 zones within the Clayton Statistical Area Level 2 (SA2) were also examined.  This SA2 includes the Monash University Clayton campus, and is selected because it is familiar to authors and likely readers. 

![Clayton SA2 zone. Source ABS.](images/Clayton.png)

- Output results for SA1 zones within the Melbourne City Statistical Area Level 3 (SA3) were also examined.  This SA3 includes Melbourne CBD, north Melbourne, Royal Park, Carlton, East Melbourne. parts of South Yarra and Prahan, and Southbank. Again, it has been selected for familiarity so as to help assess the accuracy of the reported SI results.   

![Melbourne City SA3 zone. Source: ABS.](images/Melbourne_city.png)


# Results

The following subsections discuss the results of running the code for all of Victoria for 2016 and 2021. It then looks in detail at the three selected sub-cases (the Running Creek SA1 zone, Clayton and Melbourne City) as a validation of the results. 

## Supply Index results for all of Victoria

Four files are output by this document^[Located in the 'results' subdirectory of the SA12016 branch in the github repository.]. These include the total 2016 and 2021 SI scores for each SA12016 zone^[Victoria_2016_SA_SA2016_160809.csv and Victoria_2021_SI_SA12016_210810.csv], and the SI scores by mode^[Victoria_2016_SI_df_by_mode...etc.].  

```{r Victoria_SI_outputs, echo=FALSE, warning=FALSE, message=FALSE}

victoria_2016_SI_total <- victoria_2016_SI_df_by_mode %>% adorn_totals(where = "col")
##write total to csv
write_csv2(victoria_2016_SI_total %>% select(sa1_code_2016, Total), "results/Victoria_2016_SI_SA12016_160809.csv")

#join to map data (not included in the CSV)
victoria_2016_SI_total_map <- left_join(victoria_2016_SI_total, sa1_map_data)


#create total column
victoria_2021_SI_total <- victoria_2021_SI_df_by_mode %>% adorn_totals(where = "col")
##write total to csv
write_csv2(victoria_2021_SI_total %>% select(sa1_code_2016, Total), "results/Victoria_2021_SI_SA12016_210810.csv")

#join to map data (not included in the CSV)
victoria_2021_SI_total_map <- left_join(victoria_2021_SI_total, sa1_map_data)



```


## Verifing the code output: Running Creek and Mongans Bridge, Kiewa Valley Hwy
Code output results were verified by comparison to by-hand calculations for the SA1 area 20403106915. Within this SA1 area there are only two V/Line bus stops^[Stop:ID 45125, Running Creek Rd/Kiewa Valley Hwy (Running Creek) and Stop ID: 45124, Kiewa Valley Hwy (Mongans Bridge).].  This SA1 was selected for the purposes of verifying the code output as it is relatively easy to calculate the relevant SI values as a cross-check, because there is only one bus service and two stops to include. Relevant geographic statistics are shown in Table \ref{tab:Running_Creek_SA1_2016}.  

```{r Running_Creek_SA1_2016, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "$SI_{LGA2021, 10/8/21}$", fig.show="hold", out.width="50%"}
kable(t(st_drop_geometry(sa1_map_data %>% filter(sa1_code_2016 == "20403106915"))), caption = "SA1 zone 20403106915 geographic data")
```

The area of SA1 20403106915 is `r st_drop_geometry(sa1_map_data %>% filter(sa1_code_2016 == "20403106915"))$areasqkm_2016`km^2^.  By inspection, the entire 400m radius catchment area of both of the bus stops lie entirely within the SA1 20403106915 boundaries.

Hence the $Area_{Bn}/ Area_{SA1_Area}$ term for each of the bus stops is equal to $(\pi 400^2) / 284598000 =$ `r (pi * 400 * 400 / 284598000) %>% label_scientific(digits = 3)()`.  
The number of services stopping at the two stops were extracted from the GTFS files, using instructions provided by @tidytransit_timetable on the tidytransit r package manual pages.  


```{r Running_Creek_time_table, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE}

##THe Melbourne GTFS file is very big, so I have pre-calculated this and stored in a csv.  
#gtfs <- read_gtfs("data/Melbourne/2021/210805/gtfs.zip")
#gtfs <- as_tidygtfs(gtfs)

## get the id of the first stop in the trip's stop sequence
#first_stop_id <- gtfs$stop_times %>% 
#  group_by(trip_id) %>% 
#  summarise(stop_id = stop_id[which.min(stop_sequence)])

## join with the stops table to get the stop_name
#first_stop_names <- left_join(first_stop_id, gtfs$stops, by="stop_id")

## rename the first stop_name as trip_origin
#trip_origins <- first_stop_names %>% select(trip_id, trip_origin = stop_name)

## join the trip origins back onto the trips
#gtfs$trips <- left_join(gtfs$trips, trip_origins, by = "trip_id")

#gtfs$trips %>%
 # select(route_id, trip_origin) %>%
#  head()

#if(!exists("trip_headsign", where = gtfs$trips)) {
  # get the last id of the trip's stop sequence
#  trip_headsigns <- gtfs$stop_times %>% 
 #   group_by(trip_id) %>% 
#    summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
#    left_join(gtfs$stops, by="stop_id") %>%
 #   select(trip_id, trip_headsign.computed = stop_name)

  # assign the headsign to the gtfs object 
#  gtfs$trips <- left_join(gtfs$trips, trip_headsigns, by = "trip_id")
#}

###CREAte A DEPARTURE TIME TABLE
#stop_ids <- gtfs$stops %>% 
 # filter(stop_name == "Running Creek Rd/Kiewa Valley Hwy (Running Creek)") %>% 
#  select(stop_id)

#departures <- stop_ids %>% 
#  inner_join(gtfs$stop_times %>% 
#               select(trip_id, arrival_time, 
#                      departure_time, stop_id), 
#             by = "stop_id")

#departures <- departures %>% 
#  left_join(gtfs$trips %>% 
#              select(trip_id, route_id, 
#                     service_id, trip_headsign, 
#                     trip_origin), 
#            by = "trip_id") 

#departures <- departures %>% 
#  left_join(gtfs$routes %>% 
#              select(route_id, 
#                     route_short_name), 
#            by = "route_id")

#departures %>% 
#  select(arrival_time,
#         departure_time,
#        trip_headsign,trip_origin,
#         route_id) %>%
#  head() %>%
#  knitr::kable()



##EXTRACT A SINGLE DAY


#services_on_210810 <- gtfs$.$dates_services %>% 
#  filter(date == "2021-08-10") %>% select(service_id)

#departures_210810 <- departures %>% 
#  inner_join(services_on_210810, by = "service_id")

#write_csv2(departures_210810, "results/departures_210810.csv")

departures_210810 <- read_delim("results/departures_210810.csv", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)

departures_210810 %>%
  arrange(departure_time, stop_id, route_short_name) %>% 
  select(departure_time, stop_id, route_short_name, trip_headsign) %>% 
  knitr::kable(caption = "Departure times from Running Creek Rd/Kiewa Valley Hwy (Running Creek) stop (Stop ID 45125) for 10/8/21")


```

The GTFS feed shows six departures for the stop, as shown in Table \ref{tab:Running_Creek_time_table}. Three services running towards Albury and three towards Mt Beauty. This suggests a  total of 6 arrivals to each of the two bus stops in a single day week ^[The SL~Bn~ term.] Therefore the total $SI_{SA1,2016,20403106915, 10/8/21}$ score is equal to $(2*(6* pi * 400 * 400 / 284598000))$ which is equal to `r (2*(6* pi * 400 * 400 / 284598000))`.  

The $SI_{SA1,2016,20403106915, 10/8/21}$ score calculated by the developed code is `r (victoria_2021_SI_total %>% filter(sa1_code_2016 == "20403106915"))$Total`. 

The hand-calculated $SI_{SA1,2016,20403106915, 10/8/21}$ matches that produced by the developed code^[Despite a minor rounding error or difference], suggesting that the developed code is providing the expected output.  

## Clayton SA2: SI scores for SA1 zones
This section briefly reviews the SI scores for SA1 zones within the Clayton SA2 area. SI scores for the day of the 2016 and 2021 censuses are compared in Figure \ref{fig:Clayton_SI_2021}.


```{r Clayton_SI_2021, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI scores for SA1 zones within the Clayton SA2 area, 2016 census day (left) and 2021 census day (right)", fig.show="hold", out.width="50%"}

map <- victoria_2016_SI_total_map %>%
  filter(sa2_name_2016 == "Clayton") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2() +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  # theme_void() +                    # clears other plot elements
 coord_sf()

map



map <- victoria_2021_SI_total_map %>%
  filter(sa2_name_2016 == "Clayton") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2() +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  # theme_void() +                    # clears other plot elements
 coord_sf()

map


```

The SI scores for SA1 zones within the Clayton SA2 area appear to meet expectations.  Higher scores are reported for SA1 zones that are close to the Monash University bus loop (centre of the Clayton SA2 area) and near the Clayton railway station (south-west of Clayton SA2 area).  In general there appear to have been little changes in SI between 2016 and 2021.  


```{r Compare_2016_2021_Clayton_scatterstats, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 3.5, fig.fullwidth = FALSE, fig.cap= "2016 and 2021 SI scores for SA1 zones in the Clayton SA2 area: scatterplot generated using ggstatsplot package"}

victoria_2016_2021 <- victoria_2016_SI_total
names(victoria_2016_2021) <- c("sa1_code_2016", "LRT_2016", "subway_2016", "rail_2016", "bus_2016", "ferry_2016", "cable_tram_2016", "aerial_lift_2016", "funicular_2016", "trolleybus_2016", "monorail_2016", "SI_2016")

victoria_2016_2021 <- left_join(victoria_2016_2021, victoria_2021_SI_total)
names(victoria_2016_2021) <- c("sa1_code_2016", "LRT_2016", "subway_2016", "rail_2016", "bus_2016", "ferry_2016", "cable_tram_2016", "aerial_lift_2016", "funicular_2016", "trolleybus_2016", "monorail_2016", "SI_2016",
                              "LRT_2021", "subway_2021", "rail_2021", "bus_2021", "ferry_2021", "cable_tram_2021", "aerial_lift_2021", "funicular_2021", "trolleybus_2021", "monorail_2021", "SI_2021")

victoria_2016_2021_map <- left_join(victoria_2016_2021, sa1_map_data)

ggscatterstats(
  data = victoria_2016_2021_map %>% filter(sa2_name_2016 == "Clayton"), ## data frame from which variables are taken
  x = "SI_2016", ## predictor/independent variable
  y = "SI_2021", ## dependent variable
  xlab = "2016 SI on census day", ## label for the x-axis
  ylab = "2021 SI on census day", ## label for the y-axis
 label.var = "sa1_code_2016", ## variable to use for labeling data points
point.label.args = list(alpha = 0.7, size = 1, color = "grey50"),
  xfill = "#CC79A7", ## fill for marginals on the x-axis
  yfill = "#009E73", ## fill for marginals on the y-axis
  caption = "Analysis using ggstatsplot package"
)

```

The scatter plot (Figure \ref{fig:Compare_2016_2021_Clayton_scatterstats}) indicates a significant association between the 2016 and 2021 SI scores. 

```{r Compare_2016_2021_Clayton_within_stats, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 3.5, fig.fullwidth = FALSE, fig.cap= "2016 and 2021 SI scores for SA1 zones in the Clayton SA2 area: violin and box plot generated using ggstatsplot package"}

#Change total column names to census year

names(victoria_2016_2021) <- c("sa1_code_2016", "LRT_2016", "subway_2016", "rail_2016", "bus_2016", "ferry_2016", "cable_tram_2016", "aerial_lift_2016", "funicular_2016", "trolleybus_2016", "monorail_2016", "2016",
                              "LRT_2021", "subway_2021", "rail_2021", "bus_2021", "ferry_2021", "cable_tram_2021", "aerial_lift_2021", "funicular_2021", "trolleybus_2021", "monorail_2021", "2021")

victoria_2016_2021_longer <- pivot_longer(victoria_2016_2021, cols = c("2016", "2021"), names_to = "Census", values_to = "Total SI")
victoria_2016_2021_longer_map <- left_join(victoria_2016_2021_longer, sa1_map_data)

#Change total column names to back
names(victoria_2016_2021) <- c("sa1_code_2016", "LRT_2016", "subway_2016", "rail_2016", "bus_2016", "ferry_2016", "cable_tram_2016", "aerial_lift_2016", "funicular_2016", "trolleybus_2016", "monorail_2016", "SI_2016",
                              "LRT_2021", "subway_2021", "rail_2021", "bus_2021", "ferry_2021", "cable_tram_2021", "aerial_lift_2021", "funicular_2021", "trolleybus_2021", "monorail_2021", "SI_2021")


ggwithinstats(
  data = victoria_2016_2021_longer_map  %>% filter(sa2_name_2016 == "Clayton"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)


```

However, the box and violin plot (Figure \ref{fig:Compare_2016_2021_Clayton_within_stats})indicates a small, but significant, difference between the 2016 and 2021 scores. The average score is higher in 2021 than in 2016, reflecting an increase in service levels.  




## Melbourne City SA3 zone

This section briefly reviews the SI scores for SA1 zones within the Melbourne City SA3 area. SI scores for the day of the 2016 and 2021 censuses are compared in Figure \ref{fig:Melbourne_City_SI}.


```{r Melbourne_City_SI, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI scores for SA1 zones within the Melbourne City SA3 area, 2016 census day (left) and 2021 census day (right)", fig.show="hold", out.width="50%"}

map <- victoria_2016_SI_total_map %>%
  filter(sa3_name_2016 == "Melbourne City") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2() +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  # theme_void() +                    # clears other plot elements
 coord_sf()

map



map <- victoria_2021_SI_total_map %>%
  filter(sa3_name_2016 == "Melbourne City") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2() +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  # theme_void() +                    # clears other plot elements
 coord_sf()

map


```

The SI scores for SA1 zones within the Melbourne City SA3 area appear to meet expectations.  Higher scores are reported for SA1 zones in the Melbourne CBD. In general there appear to have been little changes in SI between 2016 and 2021.  


```{r Compare_2016_2021_Melbourne_scatterstats, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 3.5, fig.fullwidth = FALSE, fig.cap= "2016 and 2021 SI scores for SA1 zones in the Melbourne City SA3 area: scatterplot generated using ggstatsplot package"}

ggscatterstats(
  data = victoria_2016_2021_map %>% filter(sa3_name_2016 == "Melbourne City"), ## data frame from which variables are taken
  x = "SI_2016", ## predictor/independent variable
  y = "SI_2021", ## dependent variable
  xlab = "2016 SI on census day", ## label for the x-axis
  ylab = "2021 SI on census day", ## label for the y-axis
 label.var = "sa1_code_2016", ## variable to use for labeling data points
point.label.args = list(alpha = 0.7, size = 1, color = "grey50"),
  xfill = "#CC79A7", ## fill for marginals on the x-axis
  yfill = "#009E73", ## fill for marginals on the y-axis
  caption = "Analysis using ggstatsplot package"
)

```

The scatter plot (Figure \ref{fig:Compare_2016_2021_Melbourne_scatterstats} indicates a significant association between the 2016 and 2021 SI scores. 

```{r Compare_2016_2021_Melbourne_City_within_stats, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 3.5, fig.fullwidth = FALSE, fig.cap= "2016 and 2021 SI scores for SA1 zones in the Melbourne City SA3 area: violin and box plot generated using ggstatsplot package"}

ggwithinstats(
  data = victoria_2016_2021_longer_map  %>% filter(sa3_name_2016 == "Melbourne City"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)


```

However, the box and violin plot (Figure \ref{fig:Compare_2016_2021_Melbourne_City_within_stats}) indicates no significant difference between the 2016 and 2021 scores (p = 0.06), even though the average score is slightly lower in 2021.  



## Examining SA1s across all of Victoria

Mapping SA1 scores across all of Victoria appears likely to result in overwhelming detail, and so is not reported here. Similarly, a scatter plot for all of the Victorian SA1s will provide a lot of detail and take a very long time to run.  Hence, only the violin and box plot is generated for all of Victoria. 

```{r Compare_2016_2021_Victoria_within_stats, echo=FALSE, warning=FALSE, message=FALSE, fig.height = 3.5, fig.fullwidth = FALSE, fig.cap= "2016 and 2021 SI scores for SA1 zones across Victoria: violin and box plot generated using ggstatsplot package"}

ggwithinstats(
  data = victoria_2016_2021_longer_map  %>% filter(state_name_2016 == "Victoria"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)


```

The box and violin plot (Figure \ref{fig:Compare_2016_2021_Victoria_within_stats} indicates a significant difference between the 2016 and 2021 scores for SA1 zones across all of Victoria. The average score is higher in 2021 than it was in 2016.  



# Discussion and Conclusions

This document is part of a project related to calculating transit Supply Index (SI) scores directly from GTFS data. It is a branch^[The SA12016_analysis branch, available at https://github.com/James-Reynolds/Transit_Supply_Index_GTFS/tree/SA12016_analysis/results] of the main project, wherein the SI scores are calculated for all SA1 zones in Victoria for the days of the 2016 and 2021 censuses. Here the 2016 SA1 boundaries are used.  

A case research approach has been adopted to check the output scores presented here.  Firstly the output score for the SA1 zone 20403106915 in the Victorian Alps has been directly compared to a hand-calculated SI score. This SA1 zone was selected as it only has two bus stops and six services per day, making it relatively easy to calculate the SA1 score by hand.  The calculated score using the code matched that calculated by hand, suggesting that the code is working as expected and providing accurate results.  

Results from two other cases were examined in detail as a check on output accuracy and quality. Results appeared to match expectations for SA1 zones within the Clayton SA2 area, with SA1 zones close to the Monash University bus loop and Clayton station having higher SI scores.  There was a small, but significant, increase in service levels between 2016 and 2021. For SA1 zones within the Melbourne City SA3 area the results similarly matched expectations. SI scores were higher for SA1 zones in the Melbourne CBD. There was no signficant change in SI scores between 2016 and 2021.  

For SA1 zones across all of Victoria, the results indicate that there has been a significant change in SI scores between 2016 and 2021, with the average score being approximately 5 percent higher in 2021 than in 2016. 

Further research may involve calculating the SA1 2016 scores for a full week around the 2016 and 2021 censuses.  However, the code is currently not very efficient and takes multiple days to run.  Efforts are underway^[In other Github branches] to improve the code, but for the moment work on this branch appears to be complete. 


# References {#references}

```{r, include=FALSE}
knitr::write_bib(file = 'packages.bib')
```

