
---
title: "Leveraging GTFS data to assess transit supply, and gaps between social needs and service provision"
runningheader: "Reynolds and Currie" # only for pdf output
author: "James Reynolds and Graham Currie"
date: "`r Sys.Date()`"
output:
  tufte::tufte_book:
    citation_package: natbib
    latex_engine: xelatex
    includes:
      in_header: "preamble.tex"
bibliography: [packages.bib, References.bib]
link-citations: yes
header-includes:
  - \usepackage{titling}
  - \pretitle{\begin{center}
    \includegraphics[width=2in,height=2in]{ptrg-logo-s.png}\LARGE\\}
  - \posttitle{\end{center}}
---

```{r setup, include=FALSE}
library(tufte)

library(tidyverse)
library(dplyr)
library(tidytransit)
library(sp)
library(absmapsdata)
library(ptinpoly)
library(magrittr)
library(ggplot2)
library(sf)
library(ASGS.foyer)
library(raster)
library(ggmap)
library(units)
library(janitor)
library(mapview)
library(ggstatsplot)
library(gtsummary)
library(moments)
library(scales)
library(gtfstools)
library(lubridate)
library(kableExtra)
library(knitr)

# invalidate cache when the tufte version changes
knitr::opts_chunk$set(cache.extra = packageVersion('tufte'))
```


  # Introduction
Transit service level indicators include those in the Transit Capacity and Quality of Service Manual (TCQSM) [@TCQSM:2013], the Transit Score metric [@WalkScore:2023tg] and many more. Practitioners, researchers and advocates seeking to use such metrics may face two inter-related challenges: firstly, there is the problem of calculating the metrics themselves for a specific location and service pattern; secondly, is the challenge of explaining the metrics, their meaning and importance those who are not specialists in transit, such as politicians, other decision-makers or the general public. 

The TCQSM specifies Levels of Service (LOS) between A and F across a range of factors^[Including service span, frequency, speed, the proportion of the population serviced, competitiveness of travel times to car-based travel, and many more.]. This scoring scheme appears likely to help towards the second aforementioned challenge; it is relatively simple to explain that A is good and F is bad^[It also matches to the A to F LOS scoring used in many traffic capacity analysis calculation systems and software.], and the detail within @TCQSM:2013 provides a resource for anyone wanting to better understand what the scores mean. However, calculation of many of TCQSM metrics may need specialised software and datasets^[For example, the Service Coverage Area metric in the TCQSM (pp. 5-8 to 5-21) may require GIS or other analysis, on-top of accurate data about population densities, stop locations and service schedules.] and it might be challenging to explain these measures^[Beyond a simplistic A is good and F is bad] or how to improve them to non-technical decision-makers, stakeholders or others involved in transit management or advocacy. The introduction of the General Transit Feed Specification (GTFS) [@GTFS] ^[ GTFS is an open, text-based format that was developed originally to allow transit information to be included in the Google Maps navigation platform [@GTFS].] and widespread release of schedule data in this format, however, has helped towards making transit metrics more broadly availabile. An example is provided in previous research by @Wong:2013aa that developed code to calculate of some of the TCQSM metrics^[@Wong:2013aa calculated daily average headways, route length and stop numbers for 50 transit operators.] directly from GTFS feed data. GTFS data also underlies many online journey planning systems^[Notably Google Maps, from back when it was called the Google Transit Feed Specification.], and Transit Score, which scores locations out of 100 for transit service levels [@WalkScore:2023tg]^[100 representing the highest levels of transit service provision, and being roughly equivalent to what might be experienced in the centre of New York; but which was actually calibrated using scores for the centre of San Francisco, Chicago, Boston, Portland, and Washington, D.C. [@WalkScore:2023tg]]. However, the TransitScore algorithm is patented and effectively a black box, meaning that it is not possible to calculate scores independently or understand how the metric might change with alteration to the transit system or services, or the surrounding environment. TransitScore, therefore fails the first of the aforementioned challenges; in that practitioners, researchers and advocates can only use those scores provided by @WalkScore:2023tg, which reflect only current service patterns. 

Previous research by @currie2007identifying developed a Transit Supply Index that is relatively easy to calculate, open (rather than a black box), and relatively simple for a non-technical audience to understand, engage with and use. This Index is based on calculating the number of transit arrivals at stops within an area of interest, with an adjustment made for the amount of the area of interest that is within a typical walk-access distance of each stop.  However, it does not appear to have been widely used, perhaps in part because it still required an analyst to obtain timetable and geographic data and undertake the calculation themselves. Since the publication of @currie2007identifying, however, such data has become much easier to obtain with more than 10,000 agencies now providing GTFS data [@GTFS]. A gap, however, is that there is not yet a method for calculating the @currie2007identifying Supply Index directly from GTFS data. 

This paper reports the development of R code to calculate the Supply Index of @currie2007identifying directly from GTFS data. The code is developed using data from a single case: the GTFS for Victoria in Australia, which includes Greater Melbourne. Cross-case comparisons to Toronto, Canada, and Washington DC, USA, are also undertaken to test the results and gain understanding of how the Supply Index might be useful for practitioners, researchers and advocates. The motivation for this research is to better understand how GTFS data might be used to produce benchmarking metrics that can be calculated using open-source code, that can be used to access proposed network changes, and that may be relatively easy for non-technical specialists to understand and use when making decisions about or advocating for changes to existing services. 

# Research context
Even a brief search shows that there is a very large number of metrics available for benchmarking transit services, for example: the Transit Cooperative Research Program (TCRP) Report 88 provides an extensive guidebook on developing a performance-measurement system [@Ryus:2003aa]; online databases are provided by the Florida Transit Information System (FTIS) [@Florida-Transit-Information-System:2018aa] and the International Association of Public Transport (UITP) [@UITP:2015aa]; while the Transport Strategy Centre of Imperial College London runs extensive annual benchmarking programmes across over 100 transit provides around the world [@Imperial-College-London:2023aa]. 

The Fielding Triangle [@FieldingGordonJ1987Mpts] provides a framework for understanding how such metrics combine service inputs, service outputs and service consumption to describe cost efficiency, cost effectiveness or service effectiveness measures. At a larger scale, @Litman:2003ab and @Litman:2016aa discuss some of the traffic, mobility, accessibility, social equity, strategic planning and other rational decision-making frames that might underlie such transit metrics, while @Reynolds:2017ah extends this into models of how institutionalism, incrementalism and other public policy models might apply to decision-making processes. Further examples are provided by @GuzmanLuisA.2017Aeit, who develop a measure of accessibility in the context of policy development and social equity for Latin American Bus Rapid Transit (BRT) based networks,  and the street space allocation metrics based around 10 ethical principles introduced by @Creutzig2020streetspaceallocation. 

However, many of these metrics are difficult to calculate, complex to explain or understand, and likely not well suited to communication with those who are not transit planners or engineers, or otherwise technical specialists. Where pre-calculated metrics are immediately available it may not be possible for  practitioners, researchers or advocates to independently generate metrics for proposed system changes or to even know exactly how scores for the existing services levels are calculated. The TCQSM and Transit Score may provide contrasting examples:  with respect to the first challenge, TCQSM metrics may require large amounts of network, service, population and other data to be assembled before the  indicators can be calculated; whereas Transit Scores are readily available^[The @WalkScore:2023tg website shows scores for locations with a published GTFS feed, eliminating the need for any calculations.]. With respect to the second challenge,  the meaning of the Transit Score appears easy to explain^[The closer to 100, the better.], but as the score is calculated by a patented algorithm it may not be easy to understand or explain the connection between real-world conditions and the score, or what might need to be done to improve the score and service levels. Nor does it appear to be possible for Transit Scores to be generated for proposed changes to networks. The TCQSM, in contrast is open-source^[In that @TCQSM:2013 provide a manual describing all the metrics and how to calculate them.]. While @Wong:2013aa provides open-source code for calculating some TCQSM metrics ^[https://github.com/jcwong86/GTFS_Explore_Tool] this is now 11 years old and does not appear to be currently maintained. Future research may involve reviewing this code and using it to analyse modern GTFS feeds. However, in this paper the aim is more modest, with the objective being to develop code to calculate the Suppy Index metric from @currie2007identifying.  


## The Suppy Index

```{marginfigure}
\begin{equation}
\label{eq:supply_index}
  SI_{area, time} = \sum{\frac{Area_{Bn}}{Area_{area}}*SL_{n, time}}
\end{equation}
```

Equation \ref{eq:supply_index}^[In Equation \ref{eq:supply_index} $SI_{area, time}$ is the Supply Index for the area of interest and a given period of time. $Area_{Bn}$ is the buffer area for each stop (n) within the area of interest. In  @currie2007identifying this was based on a radius of 400 metres for bus and tram stops, and 800 metres for railway stations. $Area_area$ is the area of the area of interest, and $SL_{n,time}$ is the number of transit arrivals for each stop for a given time period.] shows the Supply Index^[Minor adjustments have been made to generalise the equation, as @currie2007identifying focused on the context of Melbourne's Census Collection Districts (CCD) and calculations based on a week of transit service.]. An advantage of the Supply Index is that it is a relatively simple number to calculate, understand and explain. It describes the number of transit arrivals at stops within an area of interest and time frame, multiplied by a factor accounting for the proportion of the area of interest that is within typical walking distance of each stop. Hence, more services, more stops and higher frequencies would all result in an increase in Supply Index score. The Supply Index does not incorporate further aspects, such as service span,  off-peak share of service or service speed. However, including such metrics may increase the complexity of calculating and describing the index to non-transit specialists. Such simplicity is also helped by the way that the Index is additive, in that SI~[area, time]~ scores can be aggregated to calculate an overall score across multiple time periods or for a region encompassing multiple areas of interest. 

@currie2007identifying calculated the SI~[area, time]~  for various Census Collection Districts (CCDs)^[CCDs predate the introduction of Statistical Areas 1, 2, 3, and 4 (SA1, SA2, SA3, SA4), and other geographical divisions currently used by the Australian Bureau of Statistics (ABS), which may be more familiar to readers] in Melbourne using a timetable database provided by the Victorian Public Transport Authority (PTA). This predated the widespread availability of GTFS data.  A question, therefore, is how to calculate the SI using GTFS data so that SI~areas~ can be calculated and compared for any area of interest where transit service information in that format. 

# Methodology
This study adopts a case research approach by developing code to calculate Supply Indexes for Melbourne (Australia), Toronto (Canada) and Washington D.C. (USA). The case research approach serves two purposes: firstly the selected cases where used to develop, test and verify the functionality of the code produced in this study.  Secondly, aspects of the the selected cases were explored; such as the impact of forthcoming upgrades and issues of level-boarding access (i.e. non-step suitable for wheelchair, pram, mobility-aid etc.) to the Supply Index scores^[A key issue in case-based research is the duality criterion, being the need to simultaneously: be engaged with depth of the individual cases included in the study; yet also be seeking findings that are generalisable to more than just the case that are studied. This study responds to this criterion by first testing the developed code across three different transit systems, which is expected to be sufficient to validate that it is generalisable to most GTFS feeds, not specific to the quirks of the Victorian GTFS feed. Additionally, this study engages with a range of issues (level-boarding access, new routes and services, and cancelled projects) across these three cities, again seeking to demonstrate how the Supply Index code might be adapted to a range of other issues and places.].  

## Code development
Various analysis tools are available that make us of GTFS data, including the tidytransit package [@R-tidytransit] for the R statistical programming language [@R-base]. @tidytransit_departure_timetable provides code to calculate a departure timetable from a GTFS feed, and this was adapted to calculate arrivals at a stop and the SL~Bn~ term. 


```{r arrival_timetable_as_a_function, echo=FALSE, cache=TRUE}

#This was code was developed for another project (https://github.com/James-Reynolds/DEAKIN-housing-and-transit-accessibility),  based on the tidytransit vignette on producing a departure timetable (@tidytransit_departure_timetable.  There is back history availlble at at that github repository  for further details, but basically I wrote a departure_timetable_function and fixed up a bit where it wasn't accounting for through-running services.  This was then directly adjusted to create an arrival_timetable function (below) --- However, I did not adjust all the variable names in the function to reflect that it is about arrivals, not departures. 
#---also, something broke in the first few lines where it adds the trip_origins to the gtfs$trips data.  Not quite sure what broke, but the first 15 lines of the below function fixes it. 

library(tidytransit)
#gtfs <- read_gtfs("data/1google_transit.zip")
#stop_to_show <- "Wallan Railway Station (Wallan)"
#date_to_show <- "2023-04-27"

arrival_timetable_function <- function(gtfs, stop_to_show, date_to_show){
  # get the id of the first stop in the trip's stop sequence

  first_stop_id <- gtfs$stop_times %>% 
    group_by(trip_id) 

  first_stop_id <- first_stop_id %>%
      filter(stop_sequence == which.min(stop_sequence)) %>%
      summarise(trip_id, stop_id)

  # join with the stops table to get the stop_name
  first_stop_names <- left_join(first_stop_id, gtfs$stops, by="stop_id")

  # rename the first stop_name as trip_origin
  trip_origins <- first_stop_names %>% select(trip_id, trip_origin = stop_name)

  # join the trip origins back onto the trips
  gtfs$trips <- left_join(gtfs$trips, trip_origins, by = "trip_id")
  
  #### get the id of the last stop in the trip's stop sequence
  last_stop_id <- gtfs$stop_times %>% 
    group_by(trip_id) %>% 
    summarise(stop_id = stop_id[which.max(stop_sequence)])

  # join with the stops table to get the stop_name
  last_stop_names <- left_join(last_stop_id, gtfs$stops, by="stop_id")

  # rename the last stop_name as trip_destination
  trip_destinations <- last_stop_names %>% dplyr::select(trip_id, trip_destination = stop_name)

  # join the trip destinations back onto the trips
  gtfs$trips <- left_join(gtfs$trips, trip_destinations, by = "trip_id")

  
  #gtfs$trips %>%
  #  dplyr::select(route_id, trip_origin) %>%
  #  head()

  if(!exists("trip_headsign", where = gtfs$trips)) {
    # get the last id of the trip's stop sequence
    trip_headsigns <- gtfs$stop_times %>% 
      group_by(trip_id) %>% 
      summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
      left_join(gtfs$stops, by="stop_id") %>% dplyr::select(trip_id, trip_headsign.computed = stop_name)

  #create a new field with 
  trip_destination <- gtfs$stop_times %>% 
      group_by(trip_id) %>% 
      summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
      left_join(gtfs$stops, by="stop_id") %>% dplyr::select(trip_id, trip_headsign.computed = stop_name)

    
    
    # assign the headsign to the gtfs object 
    gtfs$trips <- left_join(gtfs$trips, trip_headsigns, by = "trip_id")
  }

  stop_ids <- gtfs$stops %>% 
    filter(stop_name == stop_to_show) %>% 
    dplyr::select(stop_id)

  departures <- stop_ids %>% 
    inner_join(gtfs$stop_times %>% 
                 dplyr::select(trip_id, arrival_time, 
                        departure_time, stop_id), 
               by = "stop_id")
  
  departures <- departures %>% 
    left_join(gtfs$trips %>% 
                dplyr::select(trip_id, route_id, 
                       service_id, trip_headsign, 
                       trip_origin, 
                       trip_destination), 
              by = "trip_id") 
  
  departures <- departures %>% 
    left_join(gtfs$routes %>% 
                dplyr::select(route_id, 
                       route_short_name), 
              by = "route_id")

  #remove trips where first stop is equal to the stop_to_show, as these stops originate at this stop and so do not depart
  departures <- departures %>% 
      filter(trip_origin != stop_to_show)
  
  
  #departures %>% 
  #  dplyr::select(arrival_time,
  #         departure_time,
  #         trip_headsign,trip_origin,
  #         route_id) %>%
  #  head() %>%
  #  knitr::kable()

  #head(gtfs$.$dates_services)


  services_on_180823 <- gtfs$.$dates_services %>% 
    filter(date == date_to_show) %>% dplyr::select(service_id)

  departures_180823 <- departures %>% 
    inner_join(services_on_180823, by = "service_id")

#  departures_180823 %>%
 #   arrange(departure_time, stop_id, route_short_name) %>% 
  #  dplyr::select(departure_time, stop_id, route_short_name, trip_headsign) %>% 
   # filter(departure_time >= hms::hms(hours = 7)) %>% 
   # filter(departure_time < hms::hms(hours = 7, minutes = 10)) %>% 
  #  knitr::kable()

  route_colors <- gtfs$routes %>% dplyr::select(route_id, route_short_name, route_color)
  route_colors$route_color[which(route_colors$route_color == "")] <- "454545"
  route_colors <- setNames(paste0("#", route_colors$route_color), route_colors$route_short_name)

  #No need for list of outputs anymore, as the graphs are no longer needed
  #output <- list(
   #   ggplot(departures_180823) + theme_bw() +
    #  geom_point(aes(y=trip_origin, x=arrival_time, color = route_short_name), size = 0.2) +
     # scale_x_time(breaks = seq(0, max(as.numeric(departures$departure_time)), 3600), 
      #             labels = scales::time_format("%H:%M")) +
      #theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
      #theme(legend.position = "bottom") +
      #scale_color_manual(values = route_colors) 
  #    labs(title = paste("Departures from", stop_to_show, "on", date_to_show))
  #add a return value to provide the number of services shown in the graph as an output
       #   , nrow(departures_180823)
    #  )
  #return list with graph and the number of services. 
  return(departures_180823)
  
}
#arrivals_southern_cross_230427 <- arrival_timetable_function(gtfs=mel1, stop_to_show="Southern Cross Railway Station (Melbourne City)", date_to_show="2023-04-27")
#head(arrivals_southern_cross_230427)
```



The gtfstools R package [@R-gtfstools] was used to split input GTFS feeds by mode to facilitate the buffer zone calculation.  Buffer zones of 400 metres for bus and Light Rail Transit (LRT) services and 800 metres for heavy rail, as per @currie2007identifying^[There is an extended mode definition that includes modes beyond the 10 in the GTFS standard [@filter_GTFS_by_mode], but these are not dealt with by the gtfstools package. Further research may seek to extend this such that other modes can be included, but for the purposes of this study the buffer zone was set at 400 metres for cable trams, aerial lifts such a gondolas and trolleybuses, and at 800 metres for ferries, funiculars and monorails.].  

```{r read_buffer_zone, echo=FALSE}

buffer_zone_definitions <- as_tibble(read.csv ("buffer_zones.csv"))

class(buffer_zone_definitions$code) <- "character"
buffer_zone_definitions$mode <- noquote(buffer_zone_definitions$mode)
buffer_zone_definitions$description_examples <- noquote(buffer_zone_definitions$description_examples)
class(buffer_zone_definitions$mode) <- "character"
class(buffer_zone_definitions$description_examples) <- "character"
#set buffer zone units to metres
buffer_zone_definitions$buffer <- as_units(buffer_zone_definitions$buffer, "m")

```

```{r split_gtfs_function, echo=FALSE}

split_gtfs_into_modes_and_put_in_list <- function(gtfs){ 
  gtfs_LRT <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 0))
  gtfs_subway <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 1))
  gtfs_rail <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 2))
  gtfs_bus <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 3))
  gtfs_ferry <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 4))
  gtfs_cable_tram <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 5))
  gtfs_aerial_lift <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 6))
  gtfs_funicular <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 7))
  gtfs_trolleybus <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 11))
  gtfs_monorail <- as_tidygtfs(filter_by_route_type(gtfs, route_type = 12))
 

  gtfs_into_modes_and_put_in_list <- list(
    LRT = gtfs_LRT, 
    subway = gtfs_subway,
    rail = gtfs_rail,
    bus = gtfs_bus,
    ferry = gtfs_ferry, 
    cable_tram = gtfs_cable_tram, 
    aerial_lift = gtfs_aerial_lift, 
    funicular = gtfs_funicular, 
    trolleybus = gtfs_trolleybus,
    monorail = gtfs_monorail 
  )

  return(gtfs_into_modes_and_put_in_list)
}

```

Where transit stops are located close to boundaries their catchment areas may fall into multiple areas of interest. The sp package [@R-sf] provides tools for manipulating geographic data and shape files in R. This was used to calculate the proportion of each stop's catchment area that falls into each geographical area of interest^[GTFS files define stop locations based on latitude and longitude [@GTFS], whereas the Area~Bn~ calculation needs to be provided in the same units as the Area~area~ variable, necessitating the use of a geographic transform as part of the code.].   


The SI~area~ was calculated on a mode-by-mode and stop-by-stop basis, by first determining the amount of the catchment area (Area~Bn~) that falls into each geographical area of interest for the stop in question. This is combined with the area for each geographical area of interest (Area~area~) and the number of stop arrivals within the (SL~Bn~) to calculate the contribution to the index scores made by just that single stop for every area of interest; these are then added to a cumulative total field for each area of interest; and the calculations are repeated until all stops and modes in the GTFS file have been included. 


```{r SICCD_calc_as_functions, echo=FALSE, warning=FALSE, message=FALSE}

###Temporary variables to help with writing the function
#areas_of_interest <- sa1_map_data %>%
#  filter(gcc_name_2021 == "Greater Melbourne") 
#mel3 <- read_gtfs("data/3google_transit.zip")
#mel3_list_by_mode <- split_gtfs_into_modes_and_put_in_list(mel3)
#gtfs_list_by_mode <- mel3_list_by_mode
#start_date = "2023-04-27"
#period_in_days = 2
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "sa1_code_2021"

#### The function ________
SI_calc_function <- function(areas_of_interest = areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = gtfs_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform){

  ##Initialise variables used in function
  #the top level list. First element is a tibble of areas_of_interest_id_field. The remainder of the list has one element for each day of analysis, with each element containing a tibble with the SI scores for each mode.   
  SI_list_by_date_and_mode <- list((tibble(areas_of_interest %>% select(as.character(areas_of_interest_id_field))) %>% select(!"geometry")))
  names(SI_list_by_date_and_mode) <- as.character(areas_of_interest_id_field)

  # convert to sf format and project
  areas_of_interest_sf <- areas_of_interest %>%
  # convert to simple features
  sf::st_as_sf() %>%
    st_transform(crs = EPSG_for_transform) 
  # add Area_area value to areas_of_interest_sf 
  areas_of_interest_sf <- areas_of_interest_sf %>% 
    dplyr::mutate(Area_area = st_area(areas_of_interest_sf))
  # Add SI column to areas_of_interest_sf
  areas_of_interest_sf <- areas_of_interest_sf %>% 
    dplyr::mutate(SI = 0)
    
#2-level list to put the SI results in, with each element representing one of the days that is being analysed. 
    # This becomes a list (of lists), with one element for each mode for the day_of_analysis in question (j)
    SI_for_day_of_analysis_list_by_mode <- list()
  
  #for loop that drives the first level of the list, recording the day of analysis
  for (j in seq(1, period_in_days, 1)) {
    
    ##Initialise variables used in first level of the list
    day_of_analysis = as.character(ymd(start_date) - days(1) + days(j))
    
    #dataframe to store the SIs for each area of interest by mode for day j
       SI_for_day_of_analysis_by_mode_k <- (tibble(areas_of_interest %>% select(as.character(areas_of_interest_id_field))) %>% select(!"geometry"))
    
    ##for loop that drives the second level of the list, recording SI by mode
      for (k in seq(1, length(names(gtfs_list_by_mode)), 1)){   
        #look up the buffer distance for mode k
        buffer_distance <- buffer_zone_definitions %>% filter(short_name == as.character(names(gtfs_list_by_mode[k]))) %>% select(buffer) %>% as.numeric()
     
        #add zero-ed column to store SIs for mode k
        SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k %>% tibble::add_column(a = 0)
        #change name of added column to match mode k
names(SI_for_day_of_analysis_by_mode_k) <- c( names(SI_for_day_of_analysis_by_mode_k[,1:ncol(SI_for_day_of_analysis_by_mode_k)-1]), eval(names(gtfs_list_by_mode[k])))                         
        
        #check if the gtfs mode in question has any stops - many of the modes (e.g. Monorail) will typically have zero services or stops.  If the mode in question (k) does not have any stops, then there is no further calculation required, and the existing column of zeros can be left as is. 
        if(nrow(gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]) > 0) { 
         SI_return_value_for_that_mode <- rep(0,nrow(areas_of_interest))
         #which is calculated in the following for loop, which passes over all of the stops in the gtfs file for the mode in question
          for (i in seq(1, nrow(gtfs_list_by_mode[[ as.character(names(gtfs_list_by_mode[k]))]][["stops"]]), 1)) {
      
            #create dataframe with stop i lat and lon value
            dat_sim <- data.frame(lat = gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]$stop_lat[i],
            long = gtfs_list_by_mode[[as.character(names(gtfs_list_by_mode[k]))]][["stops"]]$stop_lon[i])
            # Convert that dataframe (with stop i latitude and longitude) into a sf object, with the crs set to EPSG:4326 (which is the CRS for lat/long values), 
           # and then transform to be expressed as per the EPSG that is being used for the analysis (ie. shift to metres)
            dat_sf <- st_as_sf(dat_sim, coords = c("long", "lat"), crs = 4326) %>% 
            st_transform(crs = EPSG_for_transform)
  
            # make a circle with the buffer distance as the radius around stop i    
            dat_circles <- st_buffer(dat_sf, dist = buffer_distance)
            # Intersect the circle with the polygons
            int_circles <- st_intersection(areas_of_interest_sf, dat_circles)

            ##TEST CODE Map to check that it is working the way it is expect to.
            #map <- int_circles %>%
              #ggplot() +
              #geom_sf(aes(geometry = geometry,  # use the geometry variable
                  #fill = eval(parse(text=areas_of_interest_id_field))),     # fill by SA1_code
                #lwd = 0,                  # remove borders
                #show.legend = TRUE) +    # keep legend
              #theme_void() +                    # clears other plot elements
              #coord_sf()
              
            #map

            #calculate Area Bn 
            int_circles$area_bn <- st_area(int_circles)
            
            #drop_geometry
            int_circles <- as.tibble(int_circles[, !(colnames(int_circles) %in% "geometry")])
  
            ##Retrieve number of arrivals for that mode and day by...
            #first moving the gtfs for that mode out of gtfs_list_by_mode
            gtfs_k <- as_tidygtfs(eval(parse(text = paste("gtfs_list_by_mode$",names(gtfs_list_by_mode)[k],sep = ""))))
            # then add the number of arrivals at stop i to all rows of the int_circles dataframe. 
            int_circles$SL_Bn <- rep(
              nrow(arrival_timetable_function(gtfs = gtfs_k, stop_to_show = gtfs_list_by_mode[[
                as.character(names(gtfs_list_by_mode[k]))]]$stops$stop_name[i], date_to_show = day_of_analysis)), 
              nrow(int_circles))
    
            #Calculate SI for stop i and drop units
            int_circles$add_to_SI <- as.numeric(int_circles$area_bn / int_circles$Area_area * int_circles$SL_Bn)
  
            
            #Create ordinary tibble with Area of Interest identification code and SIs from stop i to add to the running totals
            export_to_SI_for_day_of_analysis_by_mode_k <- int_circles %>% select(c(as.character(areas_of_interest_id_field), add_to_SI)) 
            
            #drop add_SI column from dataframe reporting SI_by_mode scores up to the date loop (SI_for_day_of_analysis_by_mode_k)
            SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[, !(colnames(SI_for_day_of_analysis_by_mode_k) %in% "add_to_SI")]
  
            #merge based on eval(parse(text=areas_of_interest_id_field))
            SI_for_day_of_analysis_by_mode_k <- left_join(SI_for_day_of_analysis_by_mode_k, export_to_SI_for_day_of_analysis_by_mode_k)
  
            #convert add_to_SI to non-unit numbers
            SI_for_day_of_analysis_by_mode_k$add_to_SI <- as.vector(SI_for_day_of_analysis_by_mode_k$add_to_SI)
  
            #replace NA with 0 
            SI_for_day_of_analysis_by_mode_k[is.na(SI_for_day_of_analysis_by_mode_k)] = 0
  
            #add the SIs for stop i to the running total of SI for the mode in question
            SI_for_day_of_analysis_by_mode_k[,eval(names(gtfs_list_by_mode[k]))] <- SI_for_day_of_analysis_by_mode_k[,eval(names(gtfs_list_by_mode[k]))] + SI_for_day_of_analysis_by_mode_k$add_to_SI
          
            print(c("stop", i, "mode", k, "day", j))
            #close (i) loop for calculating SIs for stop i and adding to the running total of SI
            }
        
        #close the if(no stops in gtfs for that mode) test 
        }
       
       #close for (k) loop for calculating SI for a single mode on a single day
      }  
       
      #drop area of interest id code from dataframe of SI by mode for the day of analysis
      SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[,2:ncol(SI_for_day_of_analysis_by_mode_k)]
      
      #drop add_to_SI column from dataframe of SI by mode for the day of analysis
      SI_for_day_of_analysis_by_mode_k <- SI_for_day_of_analysis_by_mode_k[,!names(SI_for_day_of_analysis_by_mode_k) %in% "add_to_SI"]
       
            #add new element to the list_by_date for the date_of_analysis
      SI_list_by_date_and_mode <- append(SI_list_by_date_and_mode, list(SI_for_day_of_analysis_by_mode_k), after = length(SI_list_by_date_and_mode))
    
      #update name of new element to match date
      names(SI_list_by_date_and_mode) <- c(names(SI_list_by_date_and_mode)[1:length(names(SI_list_by_date_and_mode))-1], as.character(day_of_analysis))

    #close for (j) loop for creating the list of days
    }        

 return(SI_list_by_date_and_mode)    

#close function     
}
  


#function to combine all days together. Outputs a dataframe with a row for each area_of_interest and a column for each mode
convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function <- function(SI_list_by_date_and_mode = SI_list_by_date_and_mode) {
  SI_df_by_mode <- SI_list_by_date_and_mode[2:length(names(SI_list_by_date_and_mode))] %>%
  map_dfr(~setNames(.x, paste0("A", 1:ncol(.x))), .id = "Group") %>%
  group_by(Group) %>%
  mutate(ID = 1:n()) %>%
  group_by(ID) %>%
  summarize(across(-Group, .fns = sum, na.rm = TRUE)) %>%
  select(-ID)

  #update column names to match modes
  names(SI_df_by_mode) <- colnames(SI_list_by_date_and_mode[[2]])
  
  #add back area_of_interest_id_ column
  SI_df_by_mode <- cbind(SI_list_by_date_and_mode[1], SI_df_by_mode)
  
  return(SI_df_by_mode)
}



```


## Case research approach

The three cases were selected as they are familiar to the researchers. Additionally, the case selection continues the long-standing practice of comparing Melbourne and Toronto, as well as grounding one of the three cases in the context of a transit system that may be familiar to many readers^[Washington DC is where the Transportation Research Board Annual Meeting is held each year.].  

### Victoria, Australia
Victoria is the southern-most state on the Australian mainland. The state capital is in Melbourne, which has a similar metropolitan area to of Paris or London. However, with only around 5 million people Greater Melbourne has about one-third of the population density. It has an inner Central Business District (CBD) with apartments, commercial skyscrapers and extensive sporting facilities nearby; surrounded by low-density, predominately single-family-housing-dominated, inner, middle and outer suburbs. 

There are train and tram networks radiating from the CBD, but for most of the suburban areas the reality is that transit is provided by circuitious bus routes that are mostly used by those who cannot otherwise drive. An extensive freeway (and tollway) network provides connections across the Greater Melbourne area, further around Port Phillip Bay to Geelong (south-west) and the Mornington Penninsula (south-east) as well as to regional centres elsewhere in Victoria. There is a state-wide regional train and bus network, which also provides connections into South Australia, New South Wales and the Australian Capital Territory (Canberra) and local bus services in many regional towns and cities. However, accessibility to most of the city and state tends to be car-dominated.

Victoria's GTFS feed is published by Public Transport Victoria (PTV)^[There are over 400 historical releases of the  available on the transitfeeds.com website, with the first dating from March 2015 [@transitfeeds_victoria:2023aa].]. The Australian census is undertaken in early August every 5 years [With the last two being in 2016 and 2021.]. GTFS feeds were therefore selected for the first week of August of each year for the purposes of this test analysis.


Minor corrections were made to the GTFS files to remove duplicate stop_ids^[These involved minor discrepancies in either the stop name, latitude or longitude.]. The Australian Bureau of Statistics (ABS) provides a range of shape files and other resources, and this study made use of the absmapsdata R package [@R-absmapsdata] to access the 2021 Local Government Area (LGA) boundaries for the Greater Melbourne area.  The EPSG:28355 transform [@EPSG_28355] was used to shift longitude and latitude into metres, as per the Geocentric Datum of Australia 1994 (GDA95 / MGA zone 55) coordinates. 



```{r load_abs_data, messages = FALSE, warnings = FALSE, echo=FALSE, fig.fullwidth=TRUE, fig.cap="Melbourne SA1 map"}
#Load SA1 data
sa1_map_data <- sa12021

##Map Greater Melbourne SA1 areas
#map <- sa1_map_data %>%
#  filter(gcc_name_2021 == "Greater Melbourne") %>%   # let's just look Melbourne
#  ggplot() +
#  geom_sf(aes(geometry = geometry,  # use the geometry variable
#              fill = areasqkm_2021),     # fill by area size
#          lwd = 0,                  # remove borders
#          show.legend = TRUE) +    # keep legend
# # geom_point(aes(cent_long,
#  #               cent_lat),        # use the centroid long (x) and lats (y)
#   #          colour = "white") +    # make the points white
#  theme_void() +                    # clears other plot elements
#  coord_sf()

#map

p <- sa1_map_data
p <- p %>% 
  dplyr::mutate(area = st_area(p))
units(p$area) <- as_units("m^2")




```


```{r Melbourne_2021, echo=FALSE, warning=FALSE, message=FALSE}


#victoria_2021 <- read_gtfs("data/Melbourne/2021/gtfs.zip")

##identify duplicate stops
#victoria_2021_duplicated_stops <- tabyl(victoria_2021$stops$stop_id) %>% filter (n>1)
#names(victoria_2021_duplicated_stops) <- c("stop_id", "n", "percent")
#victoria_2021_duplicated_stops <- left_join(victoria_2021_duplicated_stops, victoria_2021$stops)

##discard duplicates
#victoria_2021$stops <- victoria_2021$stops[!duplicated(victoria_2021$stops$stop_id),]

##split modes
#victoria_2021_list_by_mode <- split_gtfs_into_modes_and_put_in_list(victoria_2021)


##set inputs to SI_calc function
#victoria_areas_of_interest <- lga2021 %>% filter(state_name_2021 == "Victoria")
#start_date = "2021-08-10"
#period_in_days = 7
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "lga_code_2021"

##run SI_calc function
#victoria_2021_SI_list_by_date_and_mode <- SI_calc_function(areas_of_interest =  victoria_areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = victoria_2021_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform)

##run aggregation function to create df by mode for all 7 days
#victoria_2021_SI_df_by_mode <-  convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function(victoria_2021_SI_list_by_date_and_mode)

#load pre-calculated df by mode (for just one day)
victoria_2021_SI_df_by_mode <- read.csv("victoria_2021_SI_df_by_mode_20210810.csv")
victoria_2021_SI_df_by_mode$lga_code_2021 <- as.character(victoria_2021_SI_df_by_mode$lga_code_2021)


#load LGA map data
LGA_map_data <- lga2021


#Join SI to LGA map data
victoria_2021_SI_df_by_mode_sf <- left_join(victoria_2021_SI_df_by_mode, lga2021)

```

```{r Melbourne_2016, echo=FALSE, warning=FALSE, message=FALSE}
#victoria_2016 <- read_gtfs("data/Melbourne/2016/gtfs.zip")

##identify duplicate stops
#victoria_2016_duplicated_stops <- tabyl(victoria_2016$stops$stop_id) %>% filter (n>1)
#names(victoria_2016_duplicated_stops) <- c("stop_id", "n", "percent")
#victoria_2016_duplicated_stops <- left_join(victoria_2016_duplicated_stops, victoria_2016$stops)

##discard duplicates
#victoria_2016$stops <- victoria_2016$stops[!duplicated(victoria_2016$stops$stop_id),]

##split modes
#victoria_2016_list_by_mode <- split_gtfs_into_modes_and_put_in_list(victoria_2016)


##set inputs to SI_calc function
#victoria_areas_of_interest <- lga2021 %>% filter(state_name_2021 == "Victoria")
#start_date = "2016-08-09"
#period_in_days = 7
#EPSG_for_transform = 28355
#areas_of_interest_id_field = "lga_code_2021"

##run SI_calc function
#victoria_2016_SI_list_by_date_and_mode <- SI_calc_function(areas_of_interest =  victoria_areas_of_interest, areas_of_interest_id_field = areas_of_interest_id_field, gtfs_list_by_mode = victoria_2016_list_by_mode, start_date = start_date, period_in_days = period_in_days, EPSG_for_transform = EPSG_for_transform)

##run aggregation function to create df by mode for all 7 days
#victoria_2021_SI_df_by_mode <-  convert_SI_list_by_date_and_mode_to_SI_df_by_mode.function(victoria_2021_SI_list_by_date_and_mode)


#load pre-calculated df by mode (for just one day)
victoria_2016_SI_df_by_mode <- read.csv("victoria_2016_SI_df_by_mode_20210810.csv")

victoria_2016_SI_df_by_mode$lga_code_2021 <- as.character(victoria_2016_SI_df_by_mode$lga_code_2021)


#load LGA map data
LGA_map_data <- lga2021

#Add Greater Melbourne to LGA map data
LGA_greater_melbourne <- read_csv("LGA_2021_greater_melbourne.csv")
LGA_map_data <- left_join(LGA_map_data, LGA_greater_melbourne[,2:3])

```





### Toronto, Ontario, Canada
### Washington DC, USA

# Results
The following subsections discuss the results of cases studies used to develop and test the code^[The code is available at https://github.com/James-Reynolds/Transit_Supply_Index_GTFS as an Rmarkdown file (used to typeset this paper).]. 


## Victoria, Australia

### Transit Supply Index

Figure \ref{fig:Victoria_SI_2021} show the $SI_{LGA2021, 10/8/21}$ values for Victoria (left) and Greater Melbourne (right).



```{r Victoria_SI_2021, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI for 2021 census day (August 10th) by LGA", fig.show="hold", out.width="50%"}
victoria_2021_SI_total <- victoria_2021_SI_df_by_mode %>% adorn_totals(where = "col")

victoria_2021_SI_total <- left_join(victoria_2021_SI_total, LGA_map_data)


map <- victoria_2021_SI_total %>%
  filter(state_name_2021 == "Victoria") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2(breaks = c(0.01, 1, 50), trans = "log") +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  # theme_void() +                    # clears other plot elements
 coord_sf()

map



map <- victoria_2021_SI_total %>%
  filter(greater_melbourne == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +
  scale_fill_gradient2(breaks = c(0.01, 1, 50, 500), trans = "log") +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
 # theme_void() +                    # clears other plot elements
 coord_sf()

map



```
In general, Figure \ref{fig:Victoria_SI_2021} indicates that the amount of transit service is higher for LGAs that are closer to the centre of Melbourne.  


```{r Victoria_SI_2016, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI for 2016 census day (August 9th) by LGA", fig.show="hold", out.width="50%"}
victoria_2016_SI_total <- victoria_2016_SI_df_by_mode %>% adorn_totals(where = "col")

victoria_2016_SI_total <- left_join(victoria_2016_SI_total, LGA_map_data)


map <- victoria_2016_SI_total %>%
  filter(state_name_2021 == "Victoria") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2(breaks = c(0.01, 1, 50), trans = "log") +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
  #theme_void() +                    # clears other plot elements
 coord_sf()

#map



map <- victoria_2016_SI_total %>%
  filter(greater_melbourne == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +
  scale_fill_gradient2(breaks = c(0.01, 1, 50, 500), trans = "log") +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
#  theme_void() +                    # clears other plot elements
 coord_sf()

#map






```
 

```{r Victoria_SI_2021_versus_2016, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = FALSE, fig.cap= "SI on census day, by year and LGA for all of Victoria, Greater Melbourne and non-Greater Melbourne parts of Victoria"}

victoria_2021_2016_SI_total <- tibble(lga_name_2021 = victoria_2016_SI_total[,13], "2016" = victoria_2016_SI_total[,12], "2021" = victoria_2021_SI_total[,12], greater_melbourne = victoria_2016_SI_total[,19], state_name_2021 = victoria_2016_SI_total[,15])

#ggscatterstats(
#  data = victoria_2021_2016_SI_total %>% filter(state_name_2021 == "Victoria"), ## data frame from which variables are taken
#  x = "2016", ## predictor/independent variable
#  y = "2021", ## dependent variable
#  xlab = "2016 SI on census day", ## label for the x-axis
#  ylab = "2021 SI on census day", ## label for the y-axis
 # label.var = "total_2021", ## variable to use for labeling data points
  #point.label.args = list(alpha = 0.7, size = 4, color = "grey50"),
#  xfill = "#CC79A7", ## fill for marginals on the x-axis
#  yfill = "#009E73", ## fill for marginals on the y-axis
#  caption = "Analysis using ggstatsplot package"
#)


#grouped_ggscatterstats(
#  data = victoria_2021_2016_SI_total %>% filter(state_name_2021 == "Victoria"), ## data frame from which variables are taken
#  x = "total_2016", ## predictor/independent variable
#  y = "total_2021", ## dependent variable
#  grouping.var = greater_melbourne,
#  xlab = "2016 SI on census day", ## label for the x-axis
#  ylab = "2021 SI on census day", ## label for the y-axis
#  #label.var = "total_2021", ## variable to use for labeling data points
# # point.label.args = list(alpha = 0.7, size = 4, color = "grey50"),
#  xfill = "#CC79A7", ## fill for marginals on the x-axis
#  yfill = "#009E73", ## fill for marginals on the y-axis
#  caption = "Analysis using ggstatsplot package"
#)



victoria_2021_2016_SI_total_longer <- pivot_longer(victoria_2021_2016_SI_total, cols = c("2016", "2021"), values_to = "Total SI", names_to = "Census")

ggwithinstats(
  data = victoria_2021_2016_SI_total_longer %>% filter(state_name_2021 == "Victoria"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)


```
Figure \ref{fig:Victoria_SI_2021_versus_2016} compares the SI for 2021 and 2016 for each LGA. It indicates that there are significant differences in the SI scores in 2016 and 2021.  However, it appears that the change has been relatively small, with the average SI increasing from `r (victoria_2016_SI_total %>% filter(state_name_2021 == "Victoria"))$Total %>% mean() %>% format(digits=4)` to `r (victoria_2021_SI_total %>% filter(state_name_2021 == "Victoria"))$Total %>% mean() %>% format(digits=4)`.  


```{r Victoria_SI_2021_versus_2016_greater_melbourne, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = FALSE, fig.cap= "SI on census day, by year and LGA for all of Victoria, Greater Melbourne and non-Greater Melbourne parts of Victoria"}


ggwithinstats(
  data = victoria_2021_2016_SI_total_longer %>% filter(state_name_2021 == "Victoria") %>% filter(greater_melbourne == "Greater Melbourne"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)



ggwithinstats(
  data = victoria_2021_2016_SI_total_longer %>% filter(state_name_2021 == "Victoria") %>% filter(greater_melbourne == "Elsewhere"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)

```




Figure \ref{fig:Victoria_SI_2021_versus_2016_greater_melbourne} shows that there was a significant change in SI for LGAs within Greater Melbourne, rising from `r (victoria_2016_SI_total %>% filter(state_name_2021 == "Victoria") %>% filter(greater_melbourne == "Greater Melbourne"))$Total %>% mean() %>% format(digits=4)` to `r (victoria_2021_SI_total %>% filter(state_name_2021 == "Victoria") %>% filter(greater_melbourne == "Greater Melbourne"))$Total %>% mean() %>% format(digits=4)`.  There was no significant change amongst LGAs in the rest of Victoria (Figure \ref{fig:Victoria_SI_2021_versus_2016_elsewhere}).  


```{r Victoria_SI_2021_versus_2016_elsewhere, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = FALSE, fig.cap= "SI on census day, by year and LGA for all of Victoria, Greater Melbourne and non-Greater Melbourne parts of Victoria"}

ggwithinstats(
  data = victoria_2021_2016_SI_total_longer %>% filter(state_name_2021 == "Victoria") %>% filter(greater_melbourne == "Elsewhere"), ## data frame from which variables are taken
  x = "Census", ## predictor/independent variable
  y = "Total SI", ## dependent variable
  pairwise.comparisons = TRUE,
  xlab = "Census", ## label for the x-axis
  ylab = "SI on census day", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
)

```



```{r Victoria_SI_changes, echo=FALSE, warning=FALSE, message=FALSE, fig.show="hold", out.width="50%", fig.fullwidth = TRUE, fig.cap= "Change in SI, by LGA"}

#calculate as percent
victoria_2021_SI_df_by_mode <- victoria_2021_SI_df_by_mode %>% adorn_totals(where = "col")
victoria_2016_SI_df_by_mode <- victoria_2016_SI_df_by_mode %>% adorn_totals(where = "col")
victoria_difference_2021_2016_SI <- victoria_2021_SI_df_by_mode[,2:12] / victoria_2016_SI_df_by_mode[,2:12]
victoria_difference_2021_2016_SI <- victoria_difference_2021_2016_SI - 1  
  
#get rid of Not a Numbers from the divide by 0 problem
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))

victoria_difference_2021_2016_SI[is.nan(victoria_difference_2021_2016_SI)] <- 0


victoria_difference_2021_2016_SI <- add_column(victoria_difference_2021_2016_SI, .before = "LRT", lga_code_2021 = victoria_2016_SI_df_by_mode$lga_code_2021)


victoria_difference_2021_2016_SI <- left_join(victoria_difference_2021_2016_SI, LGA_map_data)

map <- victoria_difference_2021_2016_SI %>%
  filter(state_name_2021 == "Victoria") %>%   
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +   # keep legend
  scale_fill_gradient2(labels = scales::label_percent()) +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
#  theme_void() +                    # clears other plot elements
 coord_sf() 

map



map <- victoria_difference_2021_2016_SI %>%
  filter(greater_melbourne == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
             fill = Total),     # fill by TOtal SI
          lwd = 0,                  # remove borders
         show.legend = TRUE) +
  scale_fill_gradient2(labels = scales::label_percent()) +    # fill colours on log scale
# geom_point(aes(cent_long,
    #           cent_lat),        # use the centroid long (x) and lats (y)
   #          colour = "white") +    # make the points white
#  theme_void() +                    # clears other plot elements
 coord_sf()

map


```




```{r Victoria_SI_changes_ggbetweenstats, echo=FALSE, warning=FALSE, message=FALSE, fig.margin = FALSE, fig.cap= "Change in SI on census day 2016 to 2021, by LGA"}

ggbetweenstats(
  data = victoria_difference_2021_2016_SI %>%
  filter(state_name_2021 == "Victoria"), ## data frame from which variables are taken
  x = "greater_melbourne", ## predictor/independent variable
  y =   "Total", ## dependent variable
  pairwise.comparisons = FALSE,
  xlab = "Census", ## label for the x-axis
  ylab = "Change in SI on census day, 2016 to 2021", ## label for the y-axis
  caption = "Analysis using ggstatsplot package"
) + scale_y_continuous(labels=percent)


```

Figure \ref{fig:Victoria_SI_changes} maps percentage changes in SI between 2016 and 2021. These are also shown in Figure \ref{fig:Victoria_SI_changes_ggbetweenstats}. There was no significant difference in changes in SI between LGAs in Greater Melbourne or the Rest of Victoria. The SI increased by an average of `r (victoria_difference_2021_2016_SI %>% filter(state_name_2021 == "Victoria"))$Total %>% mean() %>% percent_format(digits=4)()` for LGAs in Victoria. However, there were some LGAs that saw decreases in SI between 2016 and 2021 (Table \ref{tab:Victoria_SI_changes_falls}).   

```{r Victoria_SI_changes_falls, echo=FALSE, warning=FALSE, message=FALSE, fig.margin = FALSE, fig.cap= "Change in SI on census day 2016 to 2021, by LGA"}

kbl(victoria_difference_2021_2016_SI %>% filter(Total < 0) %>% select(c("lga_name_2021", "greater_melbourne", "LRT", "rail", "bus", "Total")) %>% adorn_pct_formatting(digits=0), align = "llrrrr", caption = "Change in SI on census day, 2016 to 2021, by LGA, for those LGAs where SI has fallen", col.names = c("LGA", "Location", "LRT", "Rail", "Bus", "Total")) %>%
    add_header_above(c(" "," ", "Change in SI" = 4))

```


The largest relative changes in SI were in Hindmarsh (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Hindmarsh"))$Total %>% percent_format(digits = 2)()`), East Gippsland (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "East Gippsland"))$Total %>% percent_format(digits = 2)()`) and West Wimmera (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "West Wimmera"))$Total %>% percent_format(digits = 2)()`). For Hindmarsh this appears to have involved the entire removal of the rail service, but offset by a small increase in bus service levels (+`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Hindmarsh"))$bus %>% percent_format(digits = 2)()`). Central Goldfields, in contrast had a doubling of train services, but an overall change of `r as.numeric((victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Central Goldfileds"))$Total) %>% percent_format(digits = 2)()`. However, some LGAs had relatively large increases in SI between 2016 and 2021 (Table \ref{tab:Victoria_SI_changes_increases}).   

```{r Victoria_SI_changes_increases, echo=FALSE, warning=FALSE, message=FALSE, fig.margin = FALSE, fig.cap= "Change in SI on census day 2016 to 2021, by LGA"}

kbl(victoria_difference_2021_2016_SI %>% filter(Total >= 0.25) %>% select(c("lga_name_2021", "greater_melbourne", "LRT", "rail", "bus", "Total")) %>% adorn_pct_formatting(digits=0), align = "llrrrr", caption = "Change in SI on census day, 2016 to 2021, by LGA, for those LGAs where SI has risen by at least 25%", col.names = c("LGA", "Location", "LRT", "Rail", "Bus", "Total")) %>%
    add_header_above(c(" "," ", "Change in SI" = 4))

```


The largest relative increases in SI were in Baw Baw (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Baw Baw"))$Total %>% percent_format(digits = 2)()`), Northern Grampians (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Northern Grampians"))$Total %>% percent_format(digits = 2)()`) and Macedon Ranges (`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Macedon Ranges"))$Total %>% percent_format(digits = 2)()`). For Baw Baw and Macedon Ranges this appears to have involved large increases in bus service levels (+`r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Baw Baw"))$bus %>% percent_format(digits = 2)()`, `r (victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Macedon Ranges"))$bus %>% percent_format(digits = 2)()`). Northern Grampians, lost all of its train services, but saw bus SI increase by `r as.numeric((victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Northern Grampians"))$bus) %>% percent_format(digits = 2)()`. Horsham, likewise, saw the loss of all of its rail services, but an increase of `r as.numeric((victoria_difference_2021_2016_SI %>% filter(lga_name_2021 == "Horsham"))$bus) %>% percent_format(digits = 2)()` in bus SI. 

  




```{r SI_by_mode, echo=FALSE, warning=FALSE, message=FALSE, fig.margin = TRUE, fig.cap= "SI by mode"}

victoria_2021_2016_SI_by_mode <- pivot_longer(victoria_2016_SI_df_by_mode %>% select(!Total), cols = 2:11, names_to = "mode", values_to = "SI") 
victoria_2021_2016_SI_by_mode <- add_column(victoria_2021_2016_SI_by_mode, .after = "lga_code_2021", Census = "2016")
  
victoria_2021_2016_SI_by_mode <- add_row(victoria_2021_2016_SI_by_mode, 
                                         pivot_longer(victoria_2021_SI_df_by_mode %>% select(!Total), cols = 2:11, names_to = "mode", values_to = "SI") %>% add_column(.after = "lga_code_2021", Census = "2021"))  

victoria_2021_2016_SI_by_mode <- left_join(victoria_2021_2016_SI_by_mode, LGA_map_data)
victoria_2021_2016_SI_by_mode$round_SI <- round(victoria_2021_2016_SI_by_mode$SI)

ggbarstats(victoria_2021_2016_SI_by_mode, 
           y = "Census",
           x = "mode",
           counts = "round_SI"
)


  
```

Figure \ref{fig:SI_by_mode} shows that there has not been a significant change in the proportion of the SI score delivered by train, tram and bus across Victoria^[Note, SI scores have been rounded to the nearest integer.]. There has no significant change across LGAs in Greater Melbourne or elsewhere in Victoria (Figure \ref{fig:SI_by_mode})


```{r SI_by_mode_greater_melbourne_versus_rest, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI by mode, Greater Melbourne and elsewhere in Victoria"}

grouped_ggbarstats(victoria_2021_2016_SI_by_mode, 
           y = "Census",
           x = "mode",
           counts = "round_SI",
           grouping.var = greater_melbourne
           
)


  
```



```{r SI_by_mode_individual_LGAs, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI by mode, Greater Melbourne and elsewhere in Victoria"}


victoria_2021_2016_SI_by_mode_wider <- pivot_wider(victoria_2021_2016_SI_by_mode, values_from = SI, names_from = mode)


more_than_one_mode <- unique((victoria_2021_2016_SI_by_mode_wider %>% filter(rail > 0 | LRT >0))$lga_name_2021)


grouped_ggbarstats(victoria_2021_2016_SI_by_mode %>% 
                 filter(lga_name_2021 %in%  more_than_one_mode) %>%
               filter(SI > 0), 
           y = Census,
           x = mode,
           counts = round_SI,
           grouping.var = lga_name_2021)


  
```


```{r SI_summary_table, echo=FALSE, warning=FALSE, message=FALSE, fig.fullwidth = TRUE, fig.cap= "SI by mode, Greater Melbourne and elsewhere in Victoria"}
                   
#victoria_2021_2016_SI_by_mode_wider %>%
# select(
#    Census,
#    lga_name_2021,
#    areasqkm_2021,
#    greater_melbourne,
#    LRT,
#    rail,
#    bus) %>%
#  tbl_summary(by = Census) %>%
#  add_p() %>% 
#  add_overall() %>%
#  add_n() %>%
#  bold_labels()


#victoria_2021_2016_SI_by_mode %>% filter(mode == "rail" | mode == "bus" | mode == "LRT") %>%
#  select(Census,
 #   mode,
#    SI,
#    lga_name_2021,
#    areasqkm_2021,
#    greater_melbourne) %>%
#  tbl_strata(
#    strata = Census,
#    .tbl_fun =
#      ~ .x %>%
#        tbl_summary(by = SI, missing = "no") %>%
#        add_n(),
#    .header = "**{strata}**, N = {n}"
#  )





#grouped_ggbarstats(victoria_2021_2016_SI_by_mode %>% filter(lga_name_2021 ==), 
#           y = "Census",
#           x = "mode",
#           counts = "round_SI",
#           grouping.var = greater_melbourne
#           
#)


  
```


### Transit needs




### Level-boarding accessibility

### The metro tunnel - adding services

### The suburban rail loop

### A transit-centric city (<15 min services)

### Squaresville

## Toronto

### Level-boarding accessibility

### Transit City: what might have been

### Viva transit: what was achieved

### Downtown relief lines 
Many proposals - look at a few of them?


### A transit-centric city (<15 min services)

### Squaresville

## Washington DC

### Level-boarding accessibility


### A transit-centric city (<15 min services)

### Squaresville


## Cross-case comparison


# Discussion



# Conclusions



# Author Contribution Statement

The authors confirm contribution to the paper as follows: study conception and
design: A. Anonymous, D. Zoolander; data collection: B. Security; analysis and
interpretation of results: A. Anonymous, B. Security; draft manuscript
preparation: A. Anonymous. All authors reviewed the results and approved
the final version of the manuscript.

# Acknowledgements
This document was prepared using the `rticles` template, created by Gregory Macfarlane, which is based on the \LaTeX originally posted by David Pritchard in 2009 and updated it in 2011, soon after TRB began allowing PDF submissions. Gregory Macfarlane and Ross Wang made adjustments to the template, and Ross Wang now maintains the \LaTeX template at <https://github.com/chiehrosswang/TRB_LaTeX_tex>. Gregory Macfarlane created the `rticles` template in 2021.


# References {#references }

```{r, include=FALSE}
knitr::write_bib(file = 'packages.bib')
```


